<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>

<body>
    <header>
        <h1>Practical Object Oriented Design - Book Notes - Chapter 5</h1>
    </header>
    <main>
        <p>This is the fifth part in my review and reading notes on the Practical Object Oriented Programming book (www.poodr.com) by Sandi Metz.</p>
<p>In the last chapter, we learned how <em>messages</em> are at the heart of design, and that messages define the <em>public interface</em> of an object. Combining these two ideas leads to some interesting design consideration, and at the core of this chapter is the concept of <strong>duck typing</strong>.</p>
<p>What <em>is</em> a <strong>Duck Type</strong>? Let's begin with where the name comes from. There's an old saying that says</p>
<blockquote>
<p>If it quacks like a duck and walks like a duck, it's a duck.</p>
</blockquote>
<p>What does that mean in the context of programming? Well, consider this:</p>
<ul>
<li>Python has no static types, and no type checking in, e.g., method signatures.</li>
<li>If you have a message to send, you can send it to any object that implements that message, regardless of the class's actual type!</li>
</ul>
<p>And the point of all this? We replace a dependency on class with a dependency on messages:</p>
<p>Recall our <code>job_helper</code> example: The first iteration had class <code>A</code> with <em>explicit</em> dependency on <em>class</em> <code>B</code>. After using dependency injection, class <code>A</code> instead depended on being passed <em>some</em> object that it could send the <code>process</code> message to. That job helper object is passed into the <code>__init__</code>, and no type checking takes place.</p>
<p>And why is this better? Because it is more <em>flexible</em>. There is less coupling, and the code is ready for change.</p>
<p><strong>Note:</strong> The following code would be very un-pythonic:</p>
<pre><code class="language-python">class A:
	def __init__(self, job_helper):
		assert isinstance(job_helper, B)
		
	...
</code></pre>
<p>All of a sudden we're back with having class <code>A</code> explicitly depend on class <code>B</code>, and making some unreasonable demands: Now the only way to pass a <code>job_helper</code> into class <code>A</code> is to pass an instance of class <code>B</code> into it. If we want to modify some behavior by passing a different class in, that class now needs to <em>inherit</em> from <code>B</code>, creating even more coupling.</p>
<p>If you <em>absolutely</em> need to exert this type of control, pick a statically typed language where you don't have to manually add boilerplate type checking code. As the autor writes, users of an object <em>need not</em> and <em>should not</em> be concerned about its class.</p>
<p>Duck typing essentially means: An object is what its interface says it is. Which means a single object can implement many different interfaces, and an application can contain many interfaces that cut across classes.</p>
<p>So let's see what that means</p>
<h2>Overlooking the Duck</h2>
<p>In this section, we follow along as the author shows how you quickly end up with messy, coupled, code if you happily code away and <em>miss</em> where there could be a <em>duck type</em> hiding among your objects.</p>
<p>The example is quite instructive, and the code that the author calls ugly is indeed a well-known <em>code smell</em>: Having a <code>switch</code> statement (or an <code>if-else-if</code> block) that checks an object's type and then sends a different message based on that object's type.</p>
<p>If you are overly focused on your existing objects, it is dangerously easy to arrive at such smelly code: You realize that your class <code>A</code> might reasonably collaborate with either class <code>B</code> or class <code>C</code>, but the message you have to send in either case is different, so you do something like</p>
<pre><code class="language-python">if isinstance(helper, B):
	result = helper.some_message()
elif isinstance(helper, C):
	result = helper.some_other_message()
</code></pre>
<p>Why is this a code smell? Because it makes your code hard to extend and introduces a strong coupling to type. If you find that yet another class <code>D</code> could be a good collaborator, you have to go to each and every of your <code>if-elif</code> blocks and add that code, duplicating a lot of knowledge in the process.</p>
<p>Remember, too, that in our list of basic dependencies, we had &quot;knowing the name of a message to send&quot;. If every single of our potential collaborators requires a different message to be sent, we end up with <em>lots</em> of these dependencies.</p>
<h2>Finding the Duck</h2>
<p>So how do we prevent ending up with messy class-dependent code? It's actually quite straightforwad and rests on a few simple observations:</p>
<ol>
<li>Our smelly code needs the type switching because we need to send a different message to each potential collaborating class based on its underlying type.</li>
<li>So if we <em>could</em> somehow send the <em>same</em> message regardless of underlying class, there'd be no need for this messy switching!</li>
</ol>
<p>But what message to send? A few more observations:</p>
<ol>
<li>Your class should have a single responsibility, and therefore:</li>
<li>Its methods should have a single goal in service of that responsibility.</li>
<li>Therefore, your class's <em>collaborators</em> arrive at the class (or the method) in service of that goal!</li>
</ol>
<p>No matter the collaborator's actual underlying class and thus overall responsibility, it arrives at your class or method with a single job: Help fulfill the class's or method's goal!</p>
<p>And there's your duck type. In the authors example, we have a <code>Trip</code> that needs to be <code>prepare</code>'d. A number of classes arrive to help it do that, including a <code>Mechanic</code>, a <code>TripCoordinator</code> and a <code>Driver</code>. No matter what a Mechanic or a Trip Coordinator or a Driver <em>generally</em> does, they arrive at the <code>prepare</code> method with one goal: Help prepare the trip. Therefore, they should all implement a <code>prepare_trip()</code> method.</p>
<p>In a statically typed language such as Java, you would now explicitly <em>declare</em> an <em>interface</em> like so</p>
<pre><code class="language-java">public interface Preparer {
	void prepare_trip(Trip trip);
}
</code></pre>
<p>and then you would explicitly state that your various classes <em>implement</em> this interface</p>
<pre><code class="language-java">public class Mechanic implements Prepapre {
	void prepare_trip(Trip trip) {
		// Specific prepare stuff for Mechanic
	}
}
</code></pre>
<p>and the trip class's prepare method would explicitly ask for a list of preparers:</p>
<pre><code class="language-java">public class Trip {
	void prepare(List&lt;Preparer&gt; preparers) {
		// Iterate over preparers and call their prepare_trip method
	}
}
</code></pre>
<p>In a dynamically typed language, however, there is no need to explicitly create and define these interfaces. But just because you did not explicitly write down that there's such a thing as a <code>Preparer</code> does not mean such a type is not hiding in your application.</p>
<p>At this point you might object: What if the different preparers need to <em>know</em> different things about the trip? In the pre-duck-type'd version, we'd have <code>prepare_bicycle(bike)</code> and maybe
<code>fill_up_vehicle(vehicle)</code> and <code>buy_food(customer)</code>. Now we want to just send <code>prepare_trip</code> each time.</p>
<p>The message sequence diagrams in the book show the answer: To prepare a trip, we send the <code>prepare_trip</code> message to our preparers, and the various implementations of <code>prepare</code> then send messages (queries, to be specific) back to the trip object: The mechanic asks for the bikes, the trip coordinator asks for the customers, and so on. This requires of course that <code>Trip</code> has a reasonable public interface that grants access to whatever the other collaborators need to know, and one should take care to follow all the good rules of interface design as discussed in the previous chapter.</p>
<h2>Consequences of Duck Typing</h2>
<p>Let's quote Sandi directly with this great bit:</p>
<blockquote>
<p>The ability to tolerate ambiguity about the class of an object is the hallmark of a confident designer. Once you begin to treat your objects as if they are defined by their behavior rather than by their class, you enter into a new realm of expressive flexible design.</p>
</blockquote>
<p>As you rework your design, removing dependencies on <em>concrete</em> classes and instead introducing duck types, you move from the concrete to the abstract. This might <em>initially</em> be harder to understand, but such code is <em>much</em> easier to change and extend.</p>
<p>The one drawback, so far, of introducing the duck type is that it is so ephemeral. When you rely on concrete classes, you can go to the implementation of the concrete class and see what it does. But in the example of the <code>Preparer</code>, there is no definite place you can go to see what <code>Preparer.prepare_trip</code> does. More on that later in this post (and in the book, of course.)</p>
<h3>Quick Side Note: Python's Magic Methods</h3>
<p>To see great use of duck typing in action, consider the way Python let's you control how <em>your</em> objects should be... printed, copied, iterated over etc:</p>
<p>Any class that implements <code>__len__</code> and <code>__getitem__()</code> for integer indices is considered by Python to be a <em>Sequence</em>. No need to explicitly declare that your class implements some <code>Sequence</code> interface. And any piece of code that expects an object over which it can iterate, or whose elements it can access via an index, will work seemlessly with your class.</p>
<h1>Writing Code that Relis on Ducks</h1>
<p>The implementation of a duck type itself is pretty easy. The hard part is in recognizing where and when you should be using one. So now the author discusses a few common patterns to look out for.</p>
<h2>Recognizing Hidden Ducks</h2>
<p>Here the author again emphasizes that <em>switching</em> on class type is a bad code smell. Say you have a variable that could be one of several different types. As mentioned above, you need to then take a step back and ask: Why do I have this variable here in the first place? It arrived at your class, at your method, for a specific purpose, and <em>that</em> purpose informs the message you <em>should</em> be sending.</p>
<p>This warning against switching on type also extends to switching on implemented methods: Imagine some horribly inconsistent API where you want to turn an object into a string and have to check individually whether your object implements <code>to_string</code> or <code>toString</code> or <code>convert_to_string</code> and then call that. An obvious eample of a missed duck type!</p>
<h2>Placing Trust in Your Ducks</h2>
<blockquote>
<p>Flexible applications are built on objects that operate on trust; it is your job to make your objects trustworthy.</p>
</blockquote>
<p>Use the code smells mentioned above to find the missing duck: What does the offending code <em>really</em> want? Then define a duck type that does just that. Implement it in the relevant classes and enjoy the clean interface!</p>
<p>What follows in the book are a few rather short sections discussing a few more fine points. Maybe it's enough to briefly summarize them:</p>
<ul>
<li>Because a duck type does not concrentely exist in the form of an explicitly defined interface, it is important to document and test their interface appropriately. More on that in Chapter 9.</li>
<li>Sometimes, duck types need to share behavior instead of just their interfaces. This is discussed in Chapter 7.</li>
</ul>
<h3>Quick Side Note: None Type</h3>
<p>As an example of a type check that <em>is</em> okay, the author gives the example where some object could be either of a certain class type, or it could be <code>None</code> (<code>NilClass</code> in the Ruby example). If that other type is a basic type, then we're in a situation where the classes we now depend on (say, <code>NoneType</code> and <code>list</code>) are much more stable than our own class. It is then okay to depend on it.</p>
<p>I would like to add a thought here, though: If your code is littered with checks for something being <code>None</code>, it might be better to use a design pattern called <em>Null Object</em>, that is, having an explicit class that represents some other class not being there:</p>
<pre><code class="language-python">if this_object is None:
	do_the_thing_where_it_is_none()
else:
	this_object.do_something_fun()
</code></pre>
<p>could be transformed to:</p>
<pre><code class="language-python">this_object.do_something_fun()
</code></pre>
<p>as long as we have</p>
<pre><code class="language-python">class FunObjectNullType:
	def do_something_fun():
		# Actually do the thing where it's None
</code></pre>
<p>That way, the responsibility of checking for <code>None</code> everywhere is removed from the client code and instead moved to a specific place: This class then has a clear, single, responsibility: Deal with some sort of default behavior.</p>
<h2>Conquering Fear of Duck Typing</h2>
<p>A great chapter! The message ultimately boils down to: If you are writing in a dynamically typed language (Ruby, Python, ...) and try to <em>force</em> it to behave like a statically typed language (Java, C#, ...) you get the <em>worst</em> of both worlds.</p>
<p>This section isn't meant to be a discussion of which sort of typing is <em>better</em>. The answer to that will very much depend on your particular situation and preferences. Both approaches undeniably have their benefits and their trade-offs.</p>
<p>Think about it like this: For a particular home improvement project, you might be best off using nails. For another project, screws will be better. For some, it will be purely a matter of taste. But no matter which you choose, once you have made the choice you better use the right tool associated. Don't pick screws for your project and then bash them in with a hammer.</p>
<h3>Subverting Duck Types with Static Typing</h3>
<p>Just as a recap: In static typic, each and every variable, method argument, and method return value have a single type, and you must explicitly declare what that type is: &quot;This variable shall be a string, and this variable shall be a floating point number and this method returns an instance of <code>SomeClass</code>&quot;. With dynamic typing, you <em>don't</em> do any of that.</p>
<p>Quick side note: Python has recently introduced type <em>hints</em>. It might <em>look</em> like static typing on the surface, but it is not. These hints are purely meant as a bit of documentation and as means for your IDE to show useful parameter hints. The python runtime itself will not care one bit whether you pass a floating point number into a method whose argument had a <code>str</code> type hint.</p>
<p>Some people are so uncomfortable with dynamic typing that they hack static typing into the language. Their code is littered with <code>isinstance</code> checks, but doing so subverts the power of dynamic typing. You cannot write beautifully flexible code with duck typing if your code fails when &quot;the wrong type&quot; arrives.</p>
<p>Another Python side note: With Python's Abstract Base Class module, you can define an <em>abstract</em> class that merely specifies the interface of your duck type. You can then implement the <code>__subclasshook__</code> class-method where <em>you</em> get to control how a type check against your abstract base class is performed. For a duck type, this would just be about checking whether certain methods are implemented. This technique has indeed the potential to give you the best of both worlds: Duck typing because your concrete classes don't need to inherit from any particular base class, and type checking in a place where you think you <em>absolutely</em> need it. That being said, strongly consider whether you <em>really</em> need to put type checks into your code.</p>
<h3>Static versus Dynamic Typing</h3>
<p>Here we get a fair comparison of the benefits of either static or dynamic typing. Note though that these benefits depend on certain assumptions. I don't think I need to recite this section here. It's pretty straightforward.</p>
<h3>Embracing Duck Typing</h3>
<p>A great discussion: Some of the perceived &quot;dangers&quot; of dynamic typing are not actually a big deal. One oft-cited benefit of static typing is that the <em>compiler</em> will catch (some, but certainly not all. Or why else would Java need a <code>NullPointerException</code>?) type errors at compile time, which is better than your program suddenly crashing at run time.</p>
<p>Technically this is true, but according to the author, this great big boogeyman of runtime type errors is greatly exaggerated. Yes, a dynamically typed language puts the burden on you to pass in objects that respond to the message they're being sent. But if your program is designed well, using trustworthy and expressive code, such type errors should be exceedingly rare. If that is the case, static typing may very well be the equivalent to Springfield's Bear Patrol: https://www.youtube.com/watch?v=fm2W0sq9ddU</p>
<h1>Summary</h1>
<p>Judge objects by what they do, not by who they are!</p>

    </main>
</body>

</html>