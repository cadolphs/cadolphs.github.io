<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
</head>

<body>
    <header>
        <h1>Intro to Building Python Extensions in Rust</h1>
    </header>
    <main>
        <p>Rust is <em>the</em> cool new systems programming language. It promises to be much safer than C/C++ while also offering a great toolchain for building
and deploying, and lots of quality-of-life features we know and love from higher-level languages.</p>
<p>One obvious use-case for any high-speed systems programming language is to write custom Python extensions in it. That way you get the
ease of use from Python without compromising on speed.</p>
<p>To make this all work, let's figure out step by step how to build a custom Python extension in Rust. I'm assuming familiarity with both these
languages; this isn't meant to be a Python or Rust tutorial.</p>
<h1>Simplest Case</h1>
<p>Let's figure out how we can call a single, simple, Rust function from Python, where the Rust function doesn't have any complicated effects and just returns a simple type that's compatible with Python's types.</p>
<p>Goal:</p>
<pre><code class="language-python">from rust_module import rust_function

x = 42
answer = rust_function(42)
assert answer == 55
</code></pre>
<pre><code class="language-rust">fn rust_function(arg: i32) -&gt; i32 {
  arg + 13
}
</code></pre>
<h2>Exploring PYO3</h2>
<p>This seems to be the Rust module (crate) of choice. Or at least it is one of them. So I'll head over to their website and see what I need to do.</p>
<p>Here's the <a href="https://pyo3.rs/v0.13.2/">guide</a> and we're interested in the section <em>Using Rust from Python</em>.</p>
<h2>The Cargo.toml</h2>
<p>So, it seems we want to create a <strong>library crate</strong> where we tell Rust to use a particular <em>type</em> of crate to make a <em>shared library</em>. I'll try to do that via <code>cargo new</code>.</p>
<pre><code class="language-bash">cargo new --lib rust_module
</code></pre>
<p>This creates a new directory and basic package settings file (<code>Cargo.toml</code>) that we'll have to edit. We'll add the <code>cdylib</code> library target, and add PyO3 to the dependencies:</p>
<pre><code>[package]
name = &quot;rust_module&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Clemens Adolphs &lt;clemens.adolphs@gmail.com&gt;&quot;]
edition = &quot;2018&quot;

[lib]
name = &quot;rust_module&quot;
crate-type = [&quot;cdylib&quot;, &quot;rlib&quot;]

[dependencies.pyo3]
version = &quot;0.13.2&quot;
features = [&quot;extension-module&quot;]
</code></pre>
<p>I'm adding the <code>rlib</code> target in case I want to add tests or code that can call this library from within Rust. The <code>cdylib</code> target tells cargo to compile a dynamic library (dylib) that code from C can talk to, or other programs that know how to talk to C libraries.</p>
<h2>MacOS: .cargo/config</h2>
<p>Apparently to compile our code on Mac, we also need to add an additional config file</p>
<pre><code>[target.x86_64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]

[target.aarch64-apple-darwin]
rustflags = [
  &quot;-C&quot;, &quot;link-arg=-undefined&quot;,
  &quot;-C&quot;, &quot;link-arg=dynamic_lookup&quot;,
]
</code></pre>
<h2>The lib.rs</h2>
<p>Following along with the guide, we can now write our actual code. Let's first do it in the way the guide does, with the function returning a Python result directly.</p>
<pre><code class="language-rust">use pyo3::prelude::*;
use pyo3::wrap_pyfunction;

#[pyfunction]
fn rust_function(arg: i32) -&gt; PyResult&lt;i32&gt; {
    Ok(arg + 13)
}

#[pymodule]
fn rust_module(py: Python, m: &amp;PyModule) -&gt; PyResult&lt;()&gt; {
    m.add_function(wrap_pyfunction!(rust_function, m)?)?;

    Ok(())
}
</code></pre>
<p>This seems quite nice and concise, actually. We grab all the stuff from the pyo3 prelude, as well as the <code>wrap_pyfunction</code> macro. The prelude gives us access to a number of commonly used definitions.</p>
<p>So to turn an ordinary function into a function we can call from Python, all we have to do is tag it with <code>#[pyfuncion]</code> and wrap the return type in a <code>PyResult</code>.</p>
<p>Then we need to add code that makes the function known to the Python module. For that, we have the <code>#[pymodule]</code> tag.</p>
<p>The function name tagged with <code>pymodule</code> must be exactly the name of the module.</p>
<p>When importing our module, python will pass in an empty module object, expecting it to be populated with our functions (and classes, presumably, if we had any). I dimly recall from my experience with C extensions for Python that this involves <em>a lot</em> of boilerplate code. Luckily, the <code>wrap_pyfuncion</code> macro takes care of all that!</p>
<h2>Making it all work</h2>
<p>Now I just call <code>cargo build --release</code> to get the library compiled, and then, for simple development and testing, where I'm not worried about packaging, I can just make a symlink to the library file, renaming it in the process, and import it from python:</p>
<pre><code class="language-rust">ln -s target/release/librust_module.dylib rust_module.so
</code></pre>
<p>And now, in the directory that has this module, I can run the following Python code successfully:</p>
<pre><code class="language-python">from rust_module import rust_function

x = 42

answer = rust_function(x)
assert answer == 55

print(f&quot;Success! {x} + 13 == {answer}&quot;)
</code></pre>
<h1>Next steps and closing thoughts</h1>
<p>Well, this was as simple as it gets for an initial step. What are some things we should explore?</p>
<ul>
<li>Move beyond primitive types. Can we take in, and return, dictionaries?</li>
<li>What about errors? If I get a Rust error somewhere, how do I turn that into a python exception?</li>
<li>Python functions have both positional and keyword arguments. How do those get mapped in a Rust function call?</li>
<li>Manually copying and renaming the library file works for testing, but there must be a better way. (And apparently there is, via the <code>maturin</code> crate / Rust package).</li>
<li>And what about classes?</li>
</ul>

    </main>
</body>

</html>