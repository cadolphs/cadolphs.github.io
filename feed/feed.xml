<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="en">
	<title>Clemens Adolphs</title>
	<subtitle>Writing about software engineering</subtitle>
	<link href="https://cadolphs.github.io/feed/feed.xml" rel="self"/>
	<link href="https://cadolphs.github.io/"/>
	<updated>2021-06-15T00:00:00Z</updated>
	<id>https://cadolphs.github.io</id>
	<author>
		<name>Clemens Adolphs</name>
		<email>clemens.adolphs@gmail.com</email>
	</author>
	
	<entry>
		<title>Intro to Building Python Extensions in Rust</title>
		<link href="https://cadolphs.github.io/blog/2021-06-15-rust-python-1/"/>
		<updated>2021-06-15T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2021-06-15-rust-python-1/</id>
		<content type="html">&lt;p&gt;Rust is &lt;em&gt;the&lt;/em&gt; cool new systems programming language. It promises to be much safer than C/C++ while also offering a great toolchain for building
and deploying, and lots of quality-of-life features we know and love from higher-level languages.&lt;/p&gt;
&lt;p&gt;One obvious use-case for any high-speed systems programming language is to write custom Python extensions in it. That way you get the
ease of use from Python without compromising on speed.&lt;/p&gt;
&lt;p&gt;To make this all work, let&#39;s figure out step by step how to build a custom Python extension in Rust. I&#39;m assuming familiarity with both these
languages; this isn&#39;t meant to be a Python or Rust tutorial.&lt;/p&gt;
&lt;h1 id=&quot;simplest-case&quot; tabindex=&quot;-1&quot;&gt;Simplest Case &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Let&#39;s figure out how we can call a single, simple, Rust function from Python, where the Rust function doesn&#39;t have any complicated effects and just returns a simple type that&#39;s compatible with Python&#39;s types.&lt;/p&gt;
&lt;p&gt;Goal:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; rust_module &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; rust_function

x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;
answer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; rust_function&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; answer &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;55&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-rust&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;rust_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;i32&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  arg &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;exploring-pyo3&quot; tabindex=&quot;-1&quot;&gt;Exploring PYO3 &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This seems to be the Rust module (crate) of choice. Or at least it is one of them. So I&#39;ll head over to their website and see what I need to do.&lt;/p&gt;
&lt;p&gt;Here&#39;s the &lt;a href=&quot;https://pyo3.rs/v0.13.2/&quot;&gt;guide&lt;/a&gt; and we&#39;re interested in the section &lt;em&gt;Using Rust from Python&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;the-cargo-toml&quot; tabindex=&quot;-1&quot;&gt;The Cargo.toml &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So, it seems we want to create a &lt;strong&gt;library crate&lt;/strong&gt; where we tell Rust to use a particular &lt;em&gt;type&lt;/em&gt; of crate to make a &lt;em&gt;shared library&lt;/em&gt;. I&#39;ll try to do that via &lt;code&gt;cargo new&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;cargo&lt;/span&gt; new &lt;span class=&quot;token parameter variable&quot;&gt;--lib&lt;/span&gt; rust_module&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This creates a new directory and basic package settings file (&lt;code&gt;Cargo.toml&lt;/code&gt;) that we&#39;ll have to edit. We&#39;ll add the &lt;code&gt;cdylib&lt;/code&gt; library target, and add PyO3 to the dependencies:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[package]
name = &amp;quot;rust_module&amp;quot;
version = &amp;quot;0.1.0&amp;quot;
authors = [&amp;quot;Clemens Adolphs &amp;lt;clemens.adolphs@gmail.com&amp;gt;&amp;quot;]
edition = &amp;quot;2018&amp;quot;

[lib]
name = &amp;quot;rust_module&amp;quot;
crate-type = [&amp;quot;cdylib&amp;quot;, &amp;quot;rlib&amp;quot;]

[dependencies.pyo3]
version = &amp;quot;0.13.2&amp;quot;
features = [&amp;quot;extension-module&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I&#39;m adding the &lt;code&gt;rlib&lt;/code&gt; target in case I want to add tests or code that can call this library from within Rust. The &lt;code&gt;cdylib&lt;/code&gt; target tells cargo to compile a dynamic library (dylib) that code from C can talk to, or other programs that know how to talk to C libraries.&lt;/p&gt;
&lt;h2 id=&quot;macos-cargo-config&quot; tabindex=&quot;-1&quot;&gt;MacOS: .cargo/config &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Apparently to compile our code on Mac, we also need to add an additional config file&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[target.x86_64-apple-darwin]
rustflags = [
  &amp;quot;-C&amp;quot;, &amp;quot;link-arg=-undefined&amp;quot;,
  &amp;quot;-C&amp;quot;, &amp;quot;link-arg=dynamic_lookup&amp;quot;,
]

[target.aarch64-apple-darwin]
rustflags = [
  &amp;quot;-C&amp;quot;, &amp;quot;link-arg=-undefined&amp;quot;,
  &amp;quot;-C&amp;quot;, &amp;quot;link-arg=dynamic_lookup&amp;quot;,
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;the-lib-rs&quot; tabindex=&quot;-1&quot;&gt;The lib.rs &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Following along with the guide, we can now write our actual code. Let&#39;s first do it in the way the guide does, with the function returning a Python result directly.&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;pyo3&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;prelude&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;pyo3&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;wrap_pyfunction&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token attribute attr-name&quot;&gt;#[pyfunction]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;rust_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PyResult&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;i32&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token class-name&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token attribute attr-name&quot;&gt;#[pymodule]&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;rust_module&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;py&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Python&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; m&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;PyModule&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;PyResult&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    m&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;add_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token macro property&quot;&gt;wrap_pyfunction!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;rust_function&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; m&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;?&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token class-name&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This seems quite nice and concise, actually. We grab all the stuff from the pyo3 prelude, as well as the &lt;code&gt;wrap_pyfunction&lt;/code&gt; macro. The prelude gives us access to a number of commonly used definitions.&lt;/p&gt;
&lt;p&gt;So to turn an ordinary function into a function we can call from Python, all we have to do is tag it with &lt;code&gt;#[pyfuncion]&lt;/code&gt; and wrap the return type in a &lt;code&gt;PyResult&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Then we need to add code that makes the function known to the Python module. For that, we have the &lt;code&gt;#[pymodule]&lt;/code&gt; tag.&lt;/p&gt;
&lt;p&gt;The function name tagged with &lt;code&gt;pymodule&lt;/code&gt; must be exactly the name of the module.&lt;/p&gt;
&lt;p&gt;When importing our module, python will pass in an empty module object, expecting it to be populated with our functions (and classes, presumably, if we had any). I dimly recall from my experience with C extensions for Python that this involves &lt;em&gt;a lot&lt;/em&gt; of boilerplate code. Luckily, the &lt;code&gt;wrap_pyfuncion&lt;/code&gt; macro takes care of all that!&lt;/p&gt;
&lt;h2 id=&quot;making-it-all-work&quot; tabindex=&quot;-1&quot;&gt;Making it all work &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now I just call &lt;code&gt;cargo build --release&lt;/code&gt; to get the library compiled, and then, for simple development and testing, where I&#39;m not worried about packaging, I can just make a symlink to the library file, renaming it in the process, and import it from python:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;ln &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;s target&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;release&lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt;librust_module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dylib rust_module&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;so&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now, in the directory that has this module, I can run the following Python code successfully:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; rust_module &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; rust_function

x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;

answer &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; rust_function&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; answer &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;55&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string-interpolation&quot;&gt;&lt;span class=&quot;token string&quot;&gt;f&quot;Success! &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt; + 13 == &lt;/span&gt;&lt;span class=&quot;token interpolation&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;answer&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;next-steps-and-closing-thoughts&quot; tabindex=&quot;-1&quot;&gt;Next steps and closing thoughts &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-06-15-rust-python-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Well, this was as simple as it gets for an initial step. What are some things we should explore?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Move beyond primitive types. Can we take in, and return, dictionaries?&lt;/li&gt;
&lt;li&gt;What about errors? If I get a Rust error somewhere, how do I turn that into a python exception?&lt;/li&gt;
&lt;li&gt;Python functions have both positional and keyword arguments. How do those get mapped in a Rust function call?&lt;/li&gt;
&lt;li&gt;Manually copying and renaming the library file works for testing, but there must be a better way. (And apparently there is, via the &lt;code&gt;maturin&lt;/code&gt; crate / Rust package).&lt;/li&gt;
&lt;li&gt;And what about classes?&lt;/li&gt;
&lt;/ul&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 9</title>
		<link href="https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/"/>
		<updated>2021-01-22T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/</id>
		<content type="html">&lt;p&gt;This is the ninth part in my review and reading notes on the Practical Object Oriented Programming book (&lt;a href=&quot;http://www.poodr.com&quot;&gt;www.poodr.com&lt;/a&gt;) by Sandi Metz.&lt;/p&gt;
&lt;p&gt;I think in this chapter, due to important differences between Python on Ruby, I will deviate the most in following along with the author.&lt;/p&gt;
&lt;p&gt;The chapter begins with a great review of the three pillars of good, well-designed, changeable code.&lt;/p&gt;
&lt;p&gt;You must:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Understand object-oriented design, so your code is capable of accommodating future change.&lt;/li&gt;
&lt;li&gt;Be skilled a &lt;em&gt;refactoring&lt;/em&gt;, so you can successfully carry out those future changes.&lt;/li&gt;
&lt;li&gt;Write &lt;strong&gt;high-value&lt;/strong&gt; tests, so that you can refactor constantly without fear.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;intentional-testing&quot; tabindex=&quot;-1&quot;&gt;Intentional Testing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;A quick recap on why we test. The reasons range from the concrete to the subtle:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Of course we test to reduce bugs.&lt;/li&gt;
&lt;li&gt;But also to provide documentation: This is how you use this class and what its contract is.&lt;/li&gt;
&lt;li&gt;Writing tests first to &lt;em&gt;improve&lt;/em&gt; design. A test is just another piece of code that collaborates with your class!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This all comes down to one overarching goal: Reduce cost! If it was easier and cheaper to just wait for bugs to show up and then find their true source and fix them, then writing unit tests would be a waste of time (and money).&lt;/p&gt;
&lt;p&gt;Invest time in good tests and hopefully get that time back via easier refactoring, better design, fewer bugs.&lt;/p&gt;
&lt;p&gt;Here then is a dilemma of the testing novice: Writing tests costs more time than it saves, until you get good ad writing tests! This is a bit like teaching someone to type with all their fingers when, all their life, they&#39;ve been a happy two-finger-seek-and-peck typer. Some people get quite fast at two-finger typing. Changing to using more fingers will initially feel awkward to them, and will in fact slow them down.&lt;/p&gt;
&lt;p&gt;So here the author follows with a great discussion of what, when, how to test.&lt;/p&gt;
&lt;h2 id=&quot;knowing-your-intentions&quot; tabindex=&quot;-1&quot;&gt;Knowing your intentions &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Benefits of testing:&lt;/p&gt;
&lt;h3 id=&quot;finding-bugs&quot; tabindex=&quot;-1&quot;&gt;Finding Bugs &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Obviously the earlier the better!&lt;/p&gt;
&lt;h3 id=&quot;supplying-documentation&quot; tabindex=&quot;-1&quot;&gt;Supplying Documentation &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Tests are a reliable documentation of design! Comments and API documentation can easily become obsolete. Tests (that are run and pass, of course) must stay true to the design!&lt;/p&gt;
&lt;p&gt;Having worked on a few larger projects myself by now, I cannot overstate how true this is. So many times I have looked at the docstring of a method or class only to discover that it is woefully out of date, referring to parameters that are not being passed in anymore, and omitting those that are.&lt;/p&gt;
&lt;p&gt;Instead, a proper test cannot lie: If you change the way a method is called, the test of that method must change with it!&lt;/p&gt;
&lt;h3 id=&quot;deferring-design-decisions&quot; tabindex=&quot;-1&quot;&gt;Deferring Design Decisions &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As explained earlier in the book, you should not make premature &amp;quot;just in case&amp;quot; design decisions. One example was: Don&#39;t create some class inheritance hierarchy with an abstract base class until you have &lt;em&gt;at least three&lt;/em&gt; concrete examples for their subclasses! If you start off your design with just one concrete class, just leave it concrete. Don&#39;t be a premature taxonomist. But: Write a proper test for the interface of your concrete class, so that, when the time comes, refactoring to a class hierarchy will not break the behavior of the concrete class.&lt;/p&gt;
&lt;p&gt;Basically, deferring a design decisions means acknowledging that the current design is probably not the best final design, but that more information is required to pick the &lt;em&gt;correct&lt;/em&gt; final (well, final until even more new information comes, anyway) design. With that in mind, you are then fully aware that there&#39;s a good chance you&#39;ll want to &lt;em&gt;refactor&lt;/em&gt; your code in the near future. And with &lt;em&gt;that&lt;/em&gt; in mind, you&#39;ll of course want the right type of test in place that will allow you to refactor without thinking about &amp;quot;what if my refactoring accidentally breaks what already worked?&amp;quot;&lt;/p&gt;
&lt;h3 id=&quot;supporting-abstractions&quot; tabindex=&quot;-1&quot;&gt;Supporting Abstractions &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A quote from the author:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Good design naturally progresses toward small independent objects that rely on abstractions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The individual abstract classes might then be easy to understand, but &lt;em&gt;how they&#39;re supposed to all fit together&lt;/em&gt; might not be immediately obvious. Tests can help with that, and ensure that classes that play certain roles do so correctly.&lt;/p&gt;
&lt;h3 id=&quot;exposing-design-flaws&quot; tabindex=&quot;-1&quot;&gt;Exposing Design Flaws &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As said above, a test is just another piece of code that wants to use your classes and collaborate with them. That means: If your design is bad, testing will be hard! A number of concrete examples of this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If setup is annoying and painful, your objects require too much context.&lt;/li&gt;
&lt;li&gt;If you cannot effectively test one object in isolation but rather have to pull in a bunch of other objects into the test, your code has too many dependencies.&lt;/li&gt;
&lt;li&gt;If the test is hard to write, the object under test might be hard to reuse.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So much for the &lt;em&gt;reasons&lt;/em&gt; to test. Next up is a great discussion of &lt;em&gt;what&lt;/em&gt; you should be testing.&lt;/p&gt;
&lt;h3 id=&quot;knowing-what-to-test&quot; tabindex=&quot;-1&quot;&gt;Knowing what to test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A reminder to what our goal is: We want to get all the benefits from testing at the lowest cost possible! How?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Write &lt;em&gt;loosely coupled tests&lt;/em&gt; about &lt;em&gt;only what matters&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It is important that tests are &lt;em&gt;loosely coupled&lt;/em&gt;, because otherwise they become hard and expensive to maintain. There&#39;s also the concept of &lt;em&gt;brittle&lt;/em&gt; tests: Tests that start failing and need to be changed for &lt;em&gt;bad&lt;/em&gt; reasons; reasons that the &lt;em&gt;rest&lt;/em&gt; of your application doesn&#39;t even care about.&lt;/p&gt;
&lt;p&gt;A few rules follow:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Test &lt;em&gt;everything&lt;/em&gt;, but &lt;em&gt;just once&lt;/em&gt;, and &lt;em&gt;in the right place&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;See objects as purely defined by the &lt;em&gt;messages&lt;/em&gt; going into and coming out of them. Treat the rest of the class as a black box (ideally, at least; there are some justifiable exceptions).&lt;/li&gt;
&lt;li&gt;See a test as just another piece of code that wants to collaborate with your class!&lt;/li&gt;
&lt;li&gt;Apply the same general design principles that apply to application code to the test code!&lt;/li&gt;
&lt;li&gt;Tests should concentrate on incoming and outgoing messages.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That last part deserves some elaboration. The &lt;em&gt;incoming&lt;/em&gt; messages are what forms the class&#39;s public interface. Some instigating object sends the messages and gets some answer in return. It is our job to test that the message returns the right thing, or otherwise has the right &lt;em&gt;effect&lt;/em&gt;. The author calls these tests &amp;quot;tests of &lt;em&gt;state&lt;/em&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;This is also a great opportunity to talk about command/query separation. In the spirit of clean code and having one method do exactly one thing, it is considered good style to have a method &lt;em&gt;either&lt;/em&gt; compute and return something or &lt;em&gt;do&lt;/em&gt; something (e.g. set some field to something or kick off any other sort of side-effect). So then for a query, we check that the return value is correct, and for a command we will have to figure out how to check the desired side-effect.&lt;/p&gt;
&lt;p&gt;If you follow these rules, your tests will have the &lt;em&gt;smallest possible coupling&lt;/em&gt; to the classes they are testing. These tests will have to change for only two reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Changes to the public interface of the class.&lt;/li&gt;
&lt;li&gt;Changes to the expected behavior of the class.&lt;br&gt;
Those are &lt;em&gt;good&lt;/em&gt; reasons to change. In the first case, obviously we have to change a test if we, say, rename a method. In the second case, we again have a good reason to change the test: The current version of the test checks for the correct current behavior of the class. If we want to &lt;em&gt;change&lt;/em&gt; that behavior, the tests need to be changed to check that.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;knowing-when-to-test&quot; tabindex=&quot;-1&quot;&gt;Knowing when to test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;You should write tests first, whenever it makes sense to do so.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nice quote from the author. There is a whole school of thought around TDD (Test-Driven Design) that emphasizes that a test should be written &lt;em&gt;before&lt;/em&gt; the code it&#39;s meant to test. This does not always make sense, according to the author, and in my own experience I tend to agree. I would argue that tests are great for exploring and guiding towards good design, but are &lt;em&gt;not&lt;/em&gt; meant as a tool for algorithm development: If you don&#39;t even know &lt;em&gt;what&lt;/em&gt; you&#39;re trying to implement, tests won&#39;t necessarily get you there. If you disagree, I challenge you to use pure TDD to write a fast solver for an NP-hard problem of your choice.&lt;/p&gt;
&lt;p&gt;Another issue is that, when writing tests first, you already need to have good design sense to write the type of test that will then lead to good design. As the author puts it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Novices often write the most complex, coupled code&lt;/li&gt;
&lt;li&gt;That makes tests super-hard to write retroactively!&lt;/li&gt;
&lt;li&gt;So then if the novice forces themselves to write the test first and &lt;em&gt;persevere&lt;/em&gt;, at least the code will be &lt;em&gt;somewhat&lt;/em&gt; reusable.&lt;/li&gt;
&lt;li&gt;It doesn&#39;t save you from bad design, though! It is perfectly possible to use TDD and still arrive at strongly coupled code!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Persevere! When it comes to design, &lt;em&gt;write tests first&lt;/em&gt;, but do so &lt;em&gt;while applying the principles of good design&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;And if you are not writing tests as the &lt;em&gt;very&lt;/em&gt; first thing, still treat them with more respect than a mere afterthought!&lt;/p&gt;
&lt;h3 id=&quot;knowing-how-to-test&quot; tabindex=&quot;-1&quot;&gt;Knowing how to test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We discuseed what and when to test, so now comes a quick overview on &lt;em&gt;how&lt;/em&gt; to test. First some logistics:&lt;/p&gt;
&lt;p&gt;First, pick a mainstream framework that suits your needs (for Python, I &lt;em&gt;really&lt;/em&gt; enjoy pytest). Just pick something reasonably stable and well-maintained.&lt;/p&gt;
&lt;p&gt;Next, consider which style of testing to use. There are two &lt;em&gt;extremes&lt;/em&gt;: You can test outside-in and inside-out. With inside-out, you would first write tests for, and then implement, the low-level building blocks of your application, and then once those are in place, piece by piece, assemble them into the larger application.&lt;/p&gt;
&lt;p&gt;With outside-in, you would first write tests for the high-level abstract concepts, specifying the general behavior you want to see from them and mocking or stubbing out the rest, and then slowly work your way down to the lower level objects.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/&quot;&gt;&amp;quot;The Pragmatic Programmer&amp;quot;&lt;/a&gt; the authors give a different view. They assert that both of the extreme approaches have flaws. With inside-out, you can spend a lot of time creating neat little classes that you &lt;em&gt;think&lt;/em&gt; will be the right sort of building blocks, only to discover much later that they don&#39;t quite fit the purpose. With outside-in, you assume that you can identify the correct abstractions and high-level concepts right away, and there is a very real danger that you engage in some &lt;em&gt;premature abstraction&lt;/em&gt;. The authors suggest, rather, to pick very small slices of functionality and develop them &lt;em&gt;end-to-end&lt;/em&gt;. This has two effects: The choice of whether to go inside-out or outside-in matters much less, because much fewer moving pieces are involved. And feedback about what the right low-level components and the right high-level abstractions are arrives much sooner.&lt;/p&gt;
&lt;p&gt;Next, some terminology. We&#39;ll be talking about the &lt;em&gt;object under test&lt;/em&gt; versus &lt;em&gt;everything else&lt;/em&gt;. In testing, we aim that our tests are as ignorant as possible about the &lt;em&gt;everything else&lt;/em&gt; part. The less a &lt;code&gt;test_class_A&lt;/code&gt; needs about classes B through Z, the better!&lt;/p&gt;
&lt;p&gt;And, finally, the tests should be as loosely coupled to the object under test as possible, which, as mentioned above, means ideally they should &lt;em&gt;only&lt;/em&gt; depend on the public interface of the object under test, and &lt;em&gt;not&lt;/em&gt; its internal fields and private methods!&lt;/p&gt;
&lt;p&gt;Now it might be that for some complex algorithmic problems you do want to check some intermediate results that are stored in private fields. Just remember that, in any case, we want our tests coupled to &lt;em&gt;stable&lt;/em&gt; things rather than less stable things!&lt;/p&gt;
&lt;h1 id=&quot;testing-incoming-messages&quot; tabindex=&quot;-1&quot;&gt;Testing incoming messages &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;The object under test has a public interface. These are the &lt;em&gt;incoming messages&lt;/em&gt;, and of course we need to test that they &amp;quot;do the right thing&amp;quot;.&lt;/p&gt;
&lt;p&gt;Assuming that the object under test already exists and you&#39;re adding tests after the fact, the first thing to check is whether anyone else actually ever calls a given method. If not, just go ahead and delete it.&lt;/p&gt;
&lt;h2 id=&quot;getters-and-setters&quot; tabindex=&quot;-1&quot;&gt;Getters and Setters &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next, don&#39;t bother writing sets for &lt;em&gt;simple&lt;/em&gt; getters and setters. First of all, if they really are just very basic getters/setters then at least in Python you should just remove them and make the corresponding attribute public. And at that point, we don&#39;t need a test that &lt;code&gt;my_class.foo = 42&lt;/code&gt; actually assigns 42 to &lt;code&gt;foo&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If, however, you have introduced more complicated logic via the &lt;code&gt;@property&lt;/code&gt; decorator, you should of course test that it behaves correctly. A small, silly example:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; radius&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; radius
        
    &lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@property&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;radius&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_diameter &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
    
    &lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@radius&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;setter&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;radius&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_diameter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; value&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is of course still pretty simple logic. Just pretend that it was actually complicated, okay? Now a &lt;em&gt;brittle&lt;/em&gt; test, that would be &lt;em&gt;strongly coupled&lt;/em&gt;, would try and make some assertions about &lt;code&gt;_diameter&lt;/code&gt;. But remember: Rely on the public interface only if at all possible. The test itself is actually quite simple, but we need it because the internal behavior is complex:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test_circle_sets_radius_correctly&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    circle &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Circle&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;
    
    circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42.5&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; circle&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42.5&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And who knows, we might even get a failing test due to floating point inaccuracies...&lt;/p&gt;
&lt;h2 id=&quot;testing-simple-methods&quot; tabindex=&quot;-1&quot;&gt;Testing simple methods &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next in line are simple methods that return a result but have no further dependencies to get their job done. That is, the only object involved in handling the incoming message is the object under test. In that case, just consider what the expectation of that method is and write the appropriate tests. Don&#39;t forget edge cases! Consider parametrizing your tests to check multiple inputs, or, going even further, use a hypothesis-testing module (&lt;code&gt;hypothesis&lt;/code&gt; works really well with pytest) to automatically have a bunch of possible inputs tested.&lt;/p&gt;
&lt;p&gt;And don&#39;t forget to test that exceptions get raised as they should. To keep the cost of testing reasonable, I would not suggest testing that any sort of intentional garbage input leads to errors: Yes, a function that clearly needs to operate on numbers will raise all sorts of &lt;code&gt;TypeError&lt;/code&gt; exceptions if you put something else in. This is already handled by the programming language itself.&lt;/p&gt;
&lt;p&gt;Instead, we should test those exceptions that our object under test explicitly raises to signal certain out-of-the-ordinary circumstances!&lt;/p&gt;
&lt;h2 id=&quot;testing-more-complicated-methods&quot; tabindex=&quot;-1&quot;&gt;Testing more complicated methods &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&amp;quot;More complicated&amp;quot; here means that the method under test in turn sends messages to other objects to achieve a desired end result. Why does that make it more complicated? If we recall the advice about treating the object under test as a black box and only relying on its public interface, we should be able to test if the method under test returns the correct result, whether that method relies on other objects.&lt;/p&gt;
&lt;p&gt;However, this sort of test might violate the &lt;em&gt;test everything only once&lt;/em&gt; idea: If a method of object &lt;code&gt;A&lt;/code&gt; relies on object &lt;code&gt;B&lt;/code&gt;, then testing that method indirectly also tests object &lt;code&gt;B&lt;/code&gt;, which means we have duplicated the effort. Ideally we would want to separate those tests such that in the tests for &lt;code&gt;A&lt;/code&gt; we make sure that the part that &lt;code&gt;A&lt;/code&gt; is responsible for is handled correctly, without including a check on &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Such coupled tests might be slow to run (if creating instances of &lt;code&gt;B&lt;/code&gt; or running its methods is costly) and might break in unexpected ways due to the coupling.&lt;/p&gt;
&lt;p&gt;The next section discusses ways to achieve better isolation:&lt;/p&gt;
&lt;h2 id=&quot;isolating-the-object-under-test&quot; tabindex=&quot;-1&quot;&gt;Isolating the object under test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If we truly want to test everything only once, we must design objects such that we can &lt;em&gt;isolate&lt;/em&gt; them when under test!&lt;/p&gt;
&lt;p&gt;Recall our simple job helper example&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_some_work&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_process_further&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, testing &lt;code&gt;do_some_work&lt;/code&gt; inevitably pulls in object &lt;code&gt;B&lt;/code&gt; into the mix, violating our goal of testing everything only once. What if &lt;code&gt;B().process(arg)&lt;/code&gt; takes a really long time?&lt;/p&gt;
&lt;p&gt;As we already discussed (in the notes to chapter 3), we have here a case where class &lt;code&gt;A&lt;/code&gt; depends on class &lt;code&gt;B&lt;/code&gt; when really it should depend on &lt;em&gt;some&lt;/em&gt; object playing the &lt;em&gt;role&lt;/em&gt; of a processor. We&#39;d refactor this code to use dependency injection:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_some_work&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_process_further&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For now, with this refactoring, the test would then inject an instance of &lt;code&gt;B&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test_do_some_work&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_some_work&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;whatever we expected&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So right now we have reduced the coupling of class &lt;code&gt;A&lt;/code&gt; to explicit class names, but we haven&#39;t quite yet solved the problem of the test of &lt;code&gt;A&lt;/code&gt; also relying on class &lt;code&gt;B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Sandi Metz reminds us here that the injected class plays a &lt;em&gt;role&lt;/em&gt;. There could just as well be &lt;em&gt;other&lt;/em&gt; objects playing that role. Why should &lt;code&gt;B&lt;/code&gt; get to play the role of &lt;code&gt;job_helper&lt;/code&gt; and not some other class that implements &lt;code&gt;process(arg)&lt;/code&gt;? What if we have &lt;em&gt;lots&lt;/em&gt; of classes that could play this role? Or what if creating those classes or running their methods was extremely costly, or had some annoying side-effects (like having to talk to some external web-server or writing a big file to disk?). Read on to find out.&lt;/p&gt;
&lt;h2 id=&quot;injecting-dependencies-as-roles&quot; tabindex=&quot;-1&quot;&gt;Injecting dependencies as roles &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;First: Before overthinking, over-engineering and over-abstracting things, consider whether creating and injecting the concrete class (in our case class &lt;code&gt;B&lt;/code&gt;) is okay after all. If it is fast and cost-effective and mirrors how it should be done in the actual application, then this is fine! For example, that class might be a lightweight utility class that groups a few useful things together; creating it and running it is fast, and it&#39;s the &lt;em&gt;only&lt;/em&gt; class playing the &lt;code&gt;job_helper&lt;/code&gt; role in your application.&lt;/p&gt;
&lt;p&gt;However, if that&#39;s not the case, here are some advanced techniques for isolation:&lt;/p&gt;
&lt;h3 id=&quot;creating-test-doubles&quot; tabindex=&quot;-1&quot;&gt;Creating test doubles &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Let&#39;s assume the concrete classes we&#39;d use for dependency injection are costly to create, or costly to run, or there&#39;s so many of them that it&#39;s not clear which one we should use.&lt;/li&gt;
&lt;li&gt;In that case, you can create &lt;em&gt;yet another class&lt;/em&gt; that plays the appropriate role, but with a very simple (&amp;quot;stub&amp;quot;) implementation. Call these &lt;code&gt;Dummy&lt;/code&gt; or &lt;code&gt;Double&lt;/code&gt;.&lt;br&gt;
In our example, this could look like this:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;JobHelperDummy&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;11&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# stub result; super-fast to execute and always reliable&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test_do_some_work&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    a &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;job_helper&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;JobHelperDummy&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_some_work&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;whatever the result would be if the intermediate result was 11&quot;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course we can add a bit more sophistication into this example; maybe the dummy-result that we&#39;ve hard-coded to 11 could be a parameter that we get to pass into the class.&lt;/p&gt;
&lt;p&gt;One note: Some people would call &lt;code&gt;JobHelperDummy&lt;/code&gt; a mock object. This is not accurate. We&#39;ll discuss mocks in a coming chapter. The reason for this occasional confusion is that tools used for creating mocks are also quite useful in creating doubles. Though as we have shown here, you can always just create a test double (or dummy) by hand.&lt;/p&gt;
&lt;p&gt;Is now all good and well? Not quite! The author points out an important pitfall. Let&#39;s say we decide to refactor class &lt;code&gt;B&lt;/code&gt; and rename the &lt;code&gt;process&lt;/code&gt; method to something else, like &lt;code&gt;super_awesome_process&lt;/code&gt;. But let&#39;s say we forget to update class &lt;code&gt;A&lt;/code&gt;, and have it still try to call &lt;code&gt;job_helper.process&lt;/code&gt;. That means our &lt;em&gt;application&lt;/em&gt; is broken. What about our tests? They still pass! &lt;code&gt;A&lt;/code&gt; tries to call &lt;code&gt;process&lt;/code&gt;, and the &lt;code&gt;JobHelperDummy&lt;/code&gt; that we pas into &lt;code&gt;A&lt;/code&gt; dutifully implements &lt;code&gt;process&lt;/code&gt;, so in test-world, all is fine!&lt;/p&gt;
&lt;p&gt;The lesson here is: If a concrete object should play a given role (i.e. implement a given duck type), there should be tests that break if the object doesn&#39;t properly play the role! That includes test doubles! More on &lt;em&gt;how&lt;/em&gt; to do that later in the chapter.&lt;/p&gt;
&lt;h1 id=&quot;testing-private-methods&quot; tabindex=&quot;-1&quot;&gt;Testing private methods &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Another great example of being practical: In an idealized world, you&#39;d never test private methods, because they&#39;ll never be called from the outside. They would be &lt;em&gt;indirectly&lt;/em&gt; tested by the tests of those public methods that in turn invoke the private method. But we&#39;re not always in this ideal world. Let&#39;s see what our options are.&lt;/p&gt;
&lt;h2 id=&quot;ignoring-private-methods-during-testing&quot; tabindex=&quot;-1&quot;&gt;Ignoring private methods during testing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Private methods are used as helpers and internal implementation details of the public methods. Thus, tests of the public methods will already be testing the private methods indirectly. Explicitly testing a private method might thus lead to unstable tests, because these private methods can change around more than the public interface.&lt;/p&gt;
&lt;p&gt;Another caveat: If you expose these private methods in your tests and basically show their &amp;quot;example usage&amp;quot;, others might be tempted to use them as well.&lt;/p&gt;
&lt;h2 id=&quot;removing-private-methods-from-the-object-under-test&quot; tabindex=&quot;-1&quot;&gt;Removing private methods from the object under test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now here is an easy way out: If your object has &lt;em&gt;no&lt;/em&gt; private methods, you don&#39;t need to fret over whether or not to test them... In any case, if your object has &lt;em&gt;too many&lt;/em&gt; private methods, maybe that object is doing too much! Could / should it be broken up into several smaller classes? And these smaller service classes would then have public methods instead of private methods.&lt;/p&gt;
&lt;p&gt;That however only makes sense if those new classes with their newly public methods will actually have a &lt;em&gt;stable&lt;/em&gt; interface. As the author points out, a method doesn&#39;t suddenly become more stable just because you made it public instead of private.&lt;/p&gt;
&lt;p&gt;Another thought is that this aversion to private methods might run counter to the clean code design principle of writing small functions. The public method would be the class&#39;s entry point to achieve a desired behavior and in turn achieve that by calling appropriate lower level private methods.&lt;/p&gt;
&lt;h2 id=&quot;choosing-to-test-a-private-method&quot; tabindex=&quot;-1&quot;&gt;Choosing to test a private method &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So when is it ever okay to &lt;em&gt;actually&lt;/em&gt; test a private method? The author gives one example, and I&#39;d like to give another.&lt;/p&gt;
&lt;p&gt;The author discusses testing private methods in the context of &lt;em&gt;starting&lt;/em&gt; with some complicated tangled mess that is the result of a lack of information: We don&#39;t know yet what the good design will look like. A good idea then is to &lt;em&gt;hide&lt;/em&gt; that mess in private methods and add &lt;em&gt;tests&lt;/em&gt; to them so that we can then refactor with confidence toward a better design.&lt;/p&gt;
&lt;p&gt;Another example where I believe testing a private method is justified concerns a &lt;em&gt;stable&lt;/em&gt; sub-routine of some complex algorithm where it wouldn&#39;t make sense to publicly expose that sub-routine yet we still want a sufficiently fine-grained (i.e. beyond the public interface of the overall algorithm) test to make sure all the individual pieces of the algorithm work as intended. It might also be that certain edge cases that we want to test are hard to bring about via the input to the public method.&lt;/p&gt;
&lt;h1 id=&quot;testing-outgoing-messages&quot; tabindex=&quot;-1&quot;&gt;Testing outgoing messages &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;In a well-designed application, an outgoing message should be &lt;em&gt;either&lt;/em&gt; a query &lt;em&gt;or&lt;/em&gt; a command. A query is a method that returns some result without any side-effects. A command is a method that does not return anything but kicks of certain side-effects.&lt;/p&gt;
&lt;p&gt;That means the object under test will send outgoing messages either to receive some information or to tell someone else in the system to do something.&lt;/p&gt;
&lt;p&gt;The important thing to note is: A query matters only to the sender. Because the query has no side-effects, whether or not it was called has no effect on the system. A command, on the other hand, might have an effect that matters to the rest of the system.&lt;/p&gt;
&lt;p&gt;So what do we test here, and how?&lt;/p&gt;
&lt;h2 id=&quot;ignore-outgoing-queries&quot; tabindex=&quot;-1&quot;&gt;Ignore outgoing queries &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Consider this example again:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper
        
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;process_input&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_some_more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, &lt;code&gt;process&lt;/code&gt; is an &lt;em&gt;outgoing&lt;/em&gt; message, sent by class &lt;code&gt;A&lt;/code&gt; to some other class. On top of that, it is a &lt;em&gt;query&lt;/em&gt;. We&#39;re asking the job helper to give us the answer to some input question, and then internally use that intermediate result. In this case, the test suite for class &lt;code&gt;A&lt;/code&gt; should not do anything at all about the outgoing &lt;code&gt;process&lt;/code&gt; message.&lt;/p&gt;
&lt;p&gt;Instead, the test suite for whichever class plays the &lt;code&gt;job_helper&lt;/code&gt; role will be testing that &lt;code&gt;process&lt;/code&gt; behaves as intended, because for &lt;em&gt;that&lt;/em&gt; class it will be an &lt;em&gt;incoming&lt;/em&gt; message.&lt;/p&gt;
&lt;h2 id=&quot;proving-command-messages&quot; tabindex=&quot;-1&quot;&gt;Proving command messages &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If it matters &lt;em&gt;to the rest of the application&lt;/em&gt; that your object &lt;em&gt;sends&lt;/em&gt; a specific method, then this expectation on the behavior needs to be tested as well.&lt;/p&gt;
&lt;p&gt;The emphasis, here, is on &lt;em&gt;rest of the application&lt;/em&gt;. If the command is merely sent to some internal auxiliary class in a way that is hidden from the rest of the application, that whole block of interactions can be treated as just one big query: Maybe in our example above the &lt;code&gt;job_helper&lt;/code&gt; needs a bit of extra setup before we can ask it to process our data. This might be done via commands that change the internal state of the job helper, but we assume that the rest of the application does not care about that. We would just treat that whole block of messages as one big query (albeit with side-effects.)&lt;/p&gt;
&lt;p&gt;The book example does a great job here with the observer pattern. The object under test now has a &lt;em&gt;responsibility&lt;/em&gt; to send out a specific method to a specific target, and we need a test that proves that. The solution here are &lt;em&gt;mocks&lt;/em&gt;. These are &lt;em&gt;special&lt;/em&gt; test double objects that record what messages they have received, and with what arguments, and then allow us to make assertions about that. In Python, you can find them in the &lt;code&gt;unittest.mock&lt;/code&gt; module.&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; unittest&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;mock &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; Mock

&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test_that_do_something_calls_job_helper_process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Mock&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    object_under_test &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;job_helper&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;job_helper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

    object_under_test&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;assert_called_with&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For this technique to work &lt;em&gt;smoothly&lt;/em&gt;, it is important that your application is well-designed, making proper use of dependency injection. In the above example, if &lt;code&gt;job_helper&lt;/code&gt; was some explicit instance of some class &lt;code&gt;B&lt;/code&gt;, and wasn&#39;t injected from the outside into class &lt;code&gt;A&lt;/code&gt;, we would have to &lt;em&gt;monkey patch&lt;/em&gt; the &lt;code&gt;job_helper&lt;/code&gt; instance inside class &lt;code&gt;A&lt;/code&gt;. This &lt;em&gt;couples&lt;/em&gt; or test to the internal structure of the class, and this is what sometimes gives mocking a reputation for leading to &lt;em&gt;brittle&lt;/em&gt; tests.&lt;/p&gt;
&lt;h1 id=&quot;testing-duck-types&quot; tabindex=&quot;-1&quot;&gt;Testing Duck Types &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Consider a duck type that&#39;s defined solely by its interface&lt;/li&gt;
&lt;li&gt;It would make sense to include a &lt;em&gt;test&lt;/em&gt; for every class that plays the role of that duck type to make sure it &lt;em&gt;honors&lt;/em&gt; that interface&lt;/li&gt;
&lt;li&gt;We &lt;em&gt;can&lt;/em&gt; of course achieve that by having them all inherit from the same abstract base class, but let&#39;s say we want to keep the duck type simple&lt;/li&gt;
&lt;li&gt;Then we basically need to test that all these classes &lt;em&gt;respond&lt;/em&gt; to the messages that the ducktype responds to&lt;/li&gt;
&lt;li&gt;Ideally we achieve that &lt;em&gt;without&lt;/em&gt; duplicating this code all the time.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For Ruby, the author gives the example of doing that with modules. Here is how the analogue could work in python:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;55&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#39;s say &lt;code&gt;foo&lt;/code&gt; is a message that belongs to some duck type &lt;code&gt;Fooable&lt;/code&gt;. We can then write&lt;br&gt;
the following mixin class:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; pytest
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FooableDuckTypeTestMixin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@pytest&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fixture&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;instance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;object_under_test&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test_implements_foo_ducktype&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; instance&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;callable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;getattr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then in the test file (using pytest) we would have:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; class_a &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; A

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;TestClassA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;FooDuckTypeTestMixin&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    object_under_test &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; A
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;test_bar&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;bar&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;55&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Things will look differently if you use a different test suite (e.g. &lt;code&gt;nose&lt;/code&gt; or just plain old &lt;code&gt;unittest&lt;/code&gt;). In pytest, the test class is merely for grouping functions and does &lt;em&gt;not&lt;/em&gt; take care of test setup. Instead of setup methods, pytest allows methods or functions be declared as fixtures. Here we turn &lt;code&gt;instance&lt;/code&gt; into a fixture with class-wide scope. Then every function inside that class with an argument named &lt;code&gt;instance&lt;/code&gt; will automatically receive, via pytest, whatever the &lt;code&gt;def instance(self)&lt;/code&gt; method returns. In this case, it&#39;s an instance of the class under test.&lt;/p&gt;
&lt;p&gt;If we now add another class &lt;code&gt;B&lt;/code&gt; that &lt;em&gt;also&lt;/em&gt; implements the &lt;code&gt;Foo&lt;/code&gt; ducktype, we also just add the duck-type test mixin to its test class, this time of course setting &lt;code&gt;object_under_test = B&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;using-role-tests-to-validate-doubles&quot; tabindex=&quot;-1&quot;&gt;Using role tests to validate doubles &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Earlier in the chapter it was discussed that using test doubles might lead to &lt;em&gt;brittle&lt;/em&gt; tests when the test double plays the role of a duck type and then the duck type changes. In this case, the application would break without the tests catching that!&lt;/p&gt;
&lt;p&gt;The solution presented by the author here is to then just use the test module / mixin for the test double as well!&lt;/p&gt;
&lt;h3 id=&quot;side-note-python&quot; tabindex=&quot;-1&quot;&gt;Side note: Python &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In Python, since we have the option to use multiple inheritance, we &lt;em&gt;could&lt;/em&gt; solve this problem (of objects not playing their roles correctly) by using abstract base classes (ABCs). Those would then &lt;em&gt;automatically&lt;/em&gt; ensure that their subclasses implement the&lt;br&gt;
correct interface.&lt;/p&gt;
&lt;p&gt;However, this can lead to a lot of noise and boilerplate code. Remember from the duck type chapter that Python has a number of &lt;em&gt;protocols&lt;/em&gt;, like the sequence protocol, that means anything that implements &lt;code&gt;__len__&lt;/code&gt; and &lt;code&gt;__getitem__&lt;/code&gt; is considered a sequence (provided &lt;code&gt;__getitem__&lt;/code&gt; works with integers from 0 to &lt;code&gt;len - 1&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Python has a cool feature though: You can override the standard way that a class checks if another class is a subclass of it. Here is how that would look like for our foo-example:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; abc &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; ABC&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; abstractmethod
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FooDuckType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;ABC&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@abstractmethod&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token triple-quoted-string string&quot;&gt;&quot;&quot;&quot;Some docstring explaining what foo should do in subclasses&quot;&quot;&quot;&lt;/span&gt;
        
    &lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@classmethod&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__subclasshook__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;cls&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; subclass&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; cls &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; FooDuckType&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;callable&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;getattr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;instance&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;True&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; NotImplemented&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What this achieves is that &lt;code&gt;isinstance(some_class, FooDuckType)&lt;/code&gt; doesn&#39;t check if&lt;br&gt;
&lt;code&gt;some_class&lt;/code&gt; &lt;em&gt;explicitly&lt;/em&gt; inherits from &lt;code&gt;FooDuckType&lt;/code&gt;. Instead, it runs the checks&lt;br&gt;
in &lt;code&gt;__subclasshook__&lt;/code&gt;. What this means in our case is that any class that implements &lt;code&gt;foo&lt;/code&gt; will be considered a subclass of &lt;code&gt;FooDuckType&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;You have to carefully evaluate whether all this extra code and type checking is necessary and helpful. We are, after all, writing in a dynamic language! To quote Sandi Metz:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Having to write your own role tests is the price you pay for the benefits of dynamic typing. In statically typed languages you can lean on the complier to enforce the interfaces of roles, but in dynamically typed languages, roles are virtual. If you fear that human communication will be insufficient to keep all players of a role in sync, write these tests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So it is a judgement call. For simple duck types, this might indeed by overkill! And for more complex types, using the abstract base class mechanism instead might be the way to go!&lt;/p&gt;
&lt;h1 id=&quot;testing-inherited-code&quot; tabindex=&quot;-1&quot;&gt;Testing inherited code &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;I believe this chapter does not quite apply as much to Python as it would to Ruby. The author describes in this chapter that, with an inheritance hierarchy, we should include a number of tests and share them via the module mechanics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Write a module to be included in each subclass&#39;s tests that ensures that the subclasses honor the interface of the superclass&lt;/li&gt;
&lt;li&gt;Write a module to be included in each subclass&#39;s tests that ensures that the subclasses &amp;quot;respond&amp;quot; to the hook methods that they&#39;re required to implement.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I feel that these tests are not needed in Python. By inheriting from a superclass, we get the automatic delegation and thus of course our subclasses respond to all the messages of the superclass, unless we dome some &lt;em&gt;really&lt;/em&gt; weird meta-programming. In addition, python has the &lt;code&gt;@abstractmethod&lt;/code&gt; decorator that forces subclasses to provide implementations for methods decorated with it.&lt;/p&gt;
&lt;p&gt;What I am wondering: If we omit these explicit interface tests, what is the worst that could happen? Does it hinder future attempts at refactoring? Would it lead to unexpected breakages in our code? I do not think so!&lt;/p&gt;
&lt;p&gt;So what &lt;em&gt;do&lt;/em&gt; we test, and how, in inheritance? It all comes down to the incoming and outgoing messages again!&lt;/p&gt;
&lt;p&gt;For the subclasses, remember that they are meant to provide &lt;em&gt;specializations&lt;/em&gt;. The hook methods represent incoming messages and as such deserve to be tested to make sure they deliver the _correct _specialization.&lt;/p&gt;
&lt;p&gt;For the superclass abstractions, we want to make sure that the hook methods get appropriately incorporated into the superclass&#39;s behavior. We achieve that by using a test double again: A simple dummy class inherits from the abstract superclass and fills in the missing pieces with simple-to-test stub methods.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Hopefully this writeup made it clear &lt;em&gt;what&lt;/em&gt;, &lt;em&gt;when&lt;/em&gt;, and &lt;em&gt;how&lt;/em&gt; we should test. Such tests are invaluable for an application and become more important the more abstract concepts there are in your code. Without such tests, the application will be too hard to change and understand!&lt;/p&gt;
&lt;h1 id=&quot;overall-summary&quot; tabindex=&quot;-1&quot;&gt;Overall Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-22-poodr-chapter9/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;This post concludes the review and book notes. I can highly recommend grabbing a copy of the book for anyone programming in a dynamically typed language, be it Ruby, Python, or something else entirely. The concepts and ideas will apply, with minor modifications, across the board.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 8</title>
		<link href="https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/"/>
		<updated>2021-01-13T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/</id>
		<content type="html">&lt;p&gt;This is the eigth part in my review and reading notes on the Practical Object Oriented Programming book (&lt;a href=&quot;http://www.poodr.com&quot;&gt;www.poodr.com&lt;/a&gt;) by Sandi Metz.&lt;/p&gt;
&lt;p&gt;Composition is the concept of combining parts into something larger, and after inheritance and modules it is the third technique for arranging behavior and code for effective reuse.&lt;/p&gt;
&lt;p&gt;In this chapter, the author first gives as an example a big refactoring of something that was previously using inheritance into something that now uses composition.&lt;/p&gt;
&lt;p&gt;The basic idea is: A complex object may have &lt;em&gt;parts&lt;/em&gt;. Being a &lt;em&gt;part&lt;/em&gt; is a &lt;em&gt;role&lt;/em&gt; and the containing object should be happy to interact and collaborate with any object that implements the appropriate interface!&lt;/p&gt;
&lt;p&gt;I will only very superficially touch on the example. Check it out in the original book.&lt;/p&gt;
&lt;h1 id=&quot;composing-a-bicycle-of-parts&quot; tabindex=&quot;-1&quot;&gt;Composing a Bicycle of Parts &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Flashback to two chapters ago (Inheritance).&lt;/li&gt;
&lt;li&gt;Recall &lt;code&gt;MountainBike&lt;/code&gt; and &lt;code&gt;RoadBike&lt;/code&gt; being subclasses of &lt;code&gt;Bike&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;What do they &lt;em&gt;differ&lt;/em&gt; in? Their spare parts!&lt;/li&gt;
&lt;li&gt;So what if we just have one &lt;em&gt;concrete&lt;/em&gt; class, &lt;code&gt;Bike&lt;/code&gt; that &lt;em&gt;has&lt;/em&gt; parts? Then the &lt;em&gt;parts&lt;/em&gt; can be specific to road bikes and mountain bikes: A road bike is a bike with road bike parts, and a mountain bike is a bike with mountain bike parts!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;updating-the-bicycle-class&quot; tabindex=&quot;-1&quot;&gt;Updating the Bicycle Class &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Here we refactor the Bicycle inheritance hierarchy and replace it with composition.&lt;/li&gt;
&lt;li&gt;Basically this is all just about delegating messages!&lt;/li&gt;
&lt;li&gt;Bicycle needs to respond to &lt;code&gt;spares&lt;/code&gt; message and therefore &lt;code&gt;delegates&lt;/code&gt; it to its &lt;code&gt;parts&lt;/code&gt; object.&lt;/li&gt;
&lt;li&gt;Contrast with inheritance: There, a &lt;code&gt;MountainBike&lt;/code&gt; needed to respond to &lt;code&gt;spares&lt;/code&gt; message and therefore &lt;em&gt;delegated&lt;/em&gt; it to the &lt;code&gt;Biycle&lt;/code&gt; superclass.&lt;/li&gt;
&lt;li&gt;Note: &lt;code&gt;Bicycle&lt;/code&gt; class now does &lt;em&gt;very little&lt;/em&gt; indeed. This is just an example. In larger example it would do &lt;em&gt;other&lt;/em&gt; things; we just moved the things related to spare parts into the &lt;code&gt;parts&lt;/code&gt; class!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Main takeaway: Inheritance leads to &lt;em&gt;automatic&lt;/em&gt; delegation. Composition requires &lt;em&gt;explicit&lt;/em&gt; delegation.&lt;/p&gt;
&lt;h2 id=&quot;creating-a-parts-hierarchy&quot; tabindex=&quot;-1&quot;&gt;Creating a Parts hierarchy &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Bicycle&lt;/code&gt; is a concrete class now; no sub-classes!&lt;/li&gt;
&lt;li&gt;Instead, subclass from &lt;code&gt;Parts&lt;/code&gt;. &lt;em&gt;There&lt;/em&gt; we will have that hierarchy.&lt;/li&gt;
&lt;li&gt;In this example, just copy over relevant code from our previous hierarchy.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Common pattern: Using composition and inheritance side by side: An object is made up of parts, and those parts are placed in a hierarchy.&lt;/p&gt;
&lt;h1 id=&quot;composing-the-parts-object&quot; tabindex=&quot;-1&quot;&gt;Composing the Parts object &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;So far, &lt;code&gt;Parts&lt;/code&gt; handled as class using inheritance.&lt;/li&gt;
&lt;li&gt;We can refactor to use composition:&lt;/li&gt;
&lt;li&gt;Obviously a &lt;code&gt;Parts&lt;/code&gt; object could be composed of many &lt;code&gt;Part&lt;/code&gt; objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;creating-the-part-object&quot; tabindex=&quot;-1&quot;&gt;Creating the Part object &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Simple class &lt;code&gt;Part&lt;/code&gt; responds to &lt;code&gt;needs_spare&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Now &lt;code&gt;Parts&lt;/code&gt; is just a simple wrapper around a &lt;code&gt;list&lt;/code&gt; of &lt;code&gt;Part&lt;/code&gt; objects&lt;/li&gt;
&lt;li&gt;It&#39;s debatable then whether a &lt;code&gt;Parts&lt;/code&gt; class is necessary or if &lt;code&gt;Bicycle&lt;/code&gt; could just hold a &lt;code&gt;list&lt;/code&gt; of &lt;code&gt;Part&lt;/code&gt; objects directly. It&#39;s &lt;em&gt;cleaner&lt;/em&gt; conceptually to make a class so interaction and manipulation of the object is &amp;quot;controlled&amp;quot;, and implementation details such as underlying data structure (&lt;code&gt;list&lt;/code&gt; versus something else) are encapsulated.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;making-the-parts-object-more-like-an-array&quot; tabindex=&quot;-1&quot;&gt;Making the Parts Object More Like an Array &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;This part felt very Ruby specific; I think Python with its abstract collections base classes might not have the same issues.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Parts&lt;/code&gt; is a wrapper around a sequence of &lt;code&gt;Part&lt;/code&gt; objects&lt;/li&gt;
&lt;li&gt;Programmers / Users &lt;em&gt;expect&lt;/em&gt; certain behavior and features of a sequence, like being able to iterate over them: &lt;code&gt;for part in parts:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;In Python, that means implementing the iterator &lt;em&gt;protocol&lt;/em&gt; (e.g. &lt;code&gt;__len__&lt;/code&gt; and &lt;code&gt;__getitem__&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;It&#39;s your call as the programmer how much work you want to put into making these protocols available.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;manufacturing-parts&quot; tabindex=&quot;-1&quot;&gt;Manufacturing Parts &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;This section does not necessarily have much to do with &lt;em&gt;composition&lt;/em&gt; but shows a useful technique in object oriented programming: Somewhere in our code we need to create the objects that play certain roles. If the knowledge needed to create these objects is encapsulated in a class, we call that class a &lt;em&gt;Factory&lt;/em&gt;. We can then ask this factory to make us certain objects that play certain roles without having to know the exact class name involved.&lt;/p&gt;
&lt;h1 id=&quot;deciding-between-inheritance-and-composition&quot; tabindex=&quot;-1&quot;&gt;Deciding Between Inheritance and Composition &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Both classical inheritance and composition are ways of organizing and arranging code, and they come with their own costs and benefits. When you use inheritance, you get the benefit of &lt;em&gt;automated&lt;/em&gt; message delegation, at the cost of placing your objects in a class hierarchy that you need to take care to get right. When you use composition, you have to deal with delegation manually, but the resulting coupling between the objects is much looser. Thus, which of the two techniques is right for your problem depends very much on the context. This section contains a few pointers and thoughts to get this right!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;General rule: When both would work, favor composition.&lt;/li&gt;
&lt;li&gt;If you cannot explicitly defend inheritance, don&#39;t use it.&lt;/li&gt;
&lt;li&gt;Inheritance is justified when there are high rewards for low risk.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;accepting-the-consequences-of-inheritance&quot; tabindex=&quot;-1&quot;&gt;Accepting the Consequences of Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;benefits&quot; tabindex=&quot;-1&quot;&gt;Benefits &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In a well-modeled class hierarchy, your code will be reasonable, usable, and exemplary, but not necessarily transparent:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Reasonable: Big changes in behavior can often be achieved with small changes at the top of the inheritance tree&lt;/li&gt;
&lt;li&gt;Usable: The code in a correct hierarchy can easily be reused by just adding yet another subclass extension to it.&lt;/li&gt;
&lt;li&gt;Exemplary: If the hierarchy is correct, then adding these new subclasses will be easy, and one can readily figure out what one must do by checking the code of existing subclasses.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;costs-of-inheritance&quot; tabindex=&quot;-1&quot;&gt;Costs of Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Note that these benefits only come to pass when you use inheritance for a problem that suits it. Otherwise, you experience the flip side of the benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Because changes at the top of the hierarchy have an outsized effect, the cost of changing things in an incorrectly modeled hierarchy is extremely large!&lt;/li&gt;
&lt;li&gt;An incorrectly modeled hierarchy is hard to re-use because the contract implied in inheriting from the hierarchy might be too restrictive.&lt;/li&gt;
&lt;li&gt;Finally, extending an incorrectly modeled hierarchy will often require ugly hacks that are &lt;em&gt;not&lt;/em&gt; exemplary of good code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;python-vs-ruby&quot; tabindex=&quot;-1&quot;&gt;Python vs Ruby &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here is one quote from the book that does not necessarily apply to Python:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Avoid writing frameworks that require users of your code to subclass your objects in order to gain your behavior. Their applications objects may already be arranged in a hierarchy; inheriting from your framework may not be possible&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Python, we have frameworks such as Django, or PyTorch, that make liberal use of inheritance, and those frameworks seem to be quite reasonable. In Python, we have of course the option to use multiple inheritance, so we can mix the framework hierarchy with our own hierarchy. Still, it is a good idea to first stop and consider whether inheritance is the &lt;em&gt;best&lt;/em&gt; way to grant access to our framework&#39;s behavior, or whether composition might be better.&lt;/p&gt;
&lt;h2 id=&quot;accepting-the-consequences-of-composition&quot; tabindex=&quot;-1&quot;&gt;Accepting the Consequences of Composition &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As mentioned before, in composition we don&#39;t depend on any pre-defined class hierarchy, and therefore the composed objects deal with message delegation manually. The pros and cons are therefore different:&lt;/p&gt;
&lt;h3 id=&quot;benefits-of-composition&quot; tabindex=&quot;-1&quot;&gt;Benefits of Composition &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If done right, composition involves the creation of many small, independent objects with single responsibilities and well-defined public interfaces. Measured against the code qualities, such a system is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Transparent. Each class is small and has a single responsibility. The effect of changes to the object are easy to understand.&lt;/li&gt;
&lt;li&gt;Reasonable. Changing the behavior of the whole often means simply plugging in a different object for a given part. An example for this is that we can turn a &lt;code&gt;RoadBike&lt;/code&gt; into a &lt;code&gt;MountainBike&lt;/code&gt; simply by plugging in a &lt;code&gt;MountainBikeParts&lt;/code&gt; object into the &lt;code&gt;Bicycle&lt;/code&gt; class rather than a &lt;code&gt;RoadBikeParts&lt;/code&gt; object.&lt;/li&gt;
&lt;li&gt;Useable. Because the objects are small and have well-defined interfaces, they are easy to re-use in new contexts.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;costs-of-composition&quot; tabindex=&quot;-1&quot;&gt;Costs of Composition &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Because we don&#39;t get the automatic message delegation that inheritance brings, a composed object must know explicitly which message to delegate to which other object. This might lead to a lot of repetition in the code. Also, if the composed object and its relation to its components is overly complicated, then even if each component is very small and easy to understand, the whole that they build might be very complex: Changing the behavior of one small component might have only a small effect on that component, but a huge effect on the behavior overall.&lt;/p&gt;
&lt;p&gt;So in this sense, composition is great at explaining how an object is made of parts, but not so good at dealing with lots of parts that are almost the same.&lt;/p&gt;
&lt;h2 id=&quot;choosing-relationships&quot; tabindex=&quot;-1&quot;&gt;Choosing Relationships &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;What follows are some rules and heuristics for picking either of classical inheritance, modules/mixins, and composition to deal with your problem. And of course it does not always have to be a binary either-or decision: You might use composition to model one relationship between an object and its parts, and then use classical inheritance among the parts that are almost identical.&lt;/p&gt;
&lt;h3 id=&quot;use-inheritance-for-is-a-relationships&quot; tabindex=&quot;-1&quot;&gt;Use Inheritance for is-a Relationships &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If the core of an object&#39;s identity is that it &lt;em&gt;is a&lt;/em&gt; specialization of a general concept, inheritance might be the right choice. Especially if this modeling results in a shallow, narrow, hierarchy and thus your costs for being wrong are low.&lt;/p&gt;
&lt;p&gt;On the flip side, do &lt;em&gt;not&lt;/em&gt; use inheritance just to get your hands at &lt;em&gt;some&lt;/em&gt; of the behavior of some existing class. Just because a dog has four legs doesn&#39;t meant you should inherit from an existing class &lt;code&gt;Table&lt;/code&gt; just to get support for legs...&lt;/p&gt;
&lt;h3 id=&quot;use-duck-types-for-behaves-like-a-relationships&quot; tabindex=&quot;-1&quot;&gt;Use Duck-Types for behaves-like-a Relationships &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When an object plays a role, but is not entirely defined by that role, we have a duck type. Examples include the &lt;code&gt;Schedulable&lt;/code&gt; and &lt;code&gt;Preparer&lt;/code&gt; duck-types of previous sections. It is common that many otherwise completely unrelated objects end up playing the same role in a given context. Placing these objects into a classical hierarchy would make little sense.&lt;/p&gt;
&lt;p&gt;Instead, identify the interface of the duck type and make sure the players of that duck type implement that interface. This can be done informally (at least in dynamic languages) or formally (e.g. by defining a purely abstract base class) depending on how much structure you need.&lt;/p&gt;
&lt;p&gt;If the duck type shares behavior, and not just the interface, use modules (in Ruby) or mixin classes (in Python).&lt;/p&gt;
&lt;h3 id=&quot;use-composition-for-has-a-relationships&quot; tabindex=&quot;-1&quot;&gt;Use Composition for has-a Relationships &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sometimes this is obvious: A car has wheels, a bicycle has a chain and other parts etc. The important thing is that a bike is &lt;em&gt;more&lt;/em&gt; than its parts.&lt;/p&gt;
&lt;p&gt;There might be cases where this is not as obvious as it could be. Let&#39;s go back to an early example. Imagine for a moment that Python&#39;s &lt;code&gt;list&lt;/code&gt; class did not already have methods for treating it as a stack (first-in-first-out data access) and we wanted to write our own &lt;code&gt;Stack&lt;/code&gt; class, with just the two methods of &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Someone might be tempted to use inheritance here:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        item &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;del&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; item
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;append&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The issue here is that a &lt;code&gt;Stack&lt;/code&gt; has some fundamental differences from a &lt;code&gt;list&lt;/code&gt;. Most importantly, data access &lt;em&gt;only&lt;/em&gt; happens at the top of the stack. But by inheriting the full interface and behavior from &lt;code&gt;list&lt;/code&gt;, nothing would stop us from accessing items in the middle:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;my_stack &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Stack&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
my_stack&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;push&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
my_stack&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;push&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

my_stack&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;5&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;my_stack&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;# [5, 2]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We &lt;em&gt;could&lt;/em&gt; try and prevent this by overriding the &lt;code&gt;__setitem__&lt;/code&gt; and &lt;code&gt;__getitem__&lt;/code&gt; methods in &lt;code&gt;Stack&lt;/code&gt; to prevent this random access, but think about what that means in terms of the class hierarchy: &lt;code&gt;Stack&lt;/code&gt; says &amp;quot;I&#39;m a list!&amp;quot; but then says &amp;quot;Yeah but don&#39;t access me like a list!&amp;quot;. In other words, the &lt;code&gt;Stack&lt;/code&gt; class is &lt;em&gt;not&lt;/em&gt; substitutable for the &lt;code&gt;list&lt;/code&gt; class!&lt;/p&gt;
&lt;p&gt;It would be much more accurate to say that a stack &lt;em&gt;has a&lt;/em&gt; list (or whatever else we decide to use internally for storage):&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Stack&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_items &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        item &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_items&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;del&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_items&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; item
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; value&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_items&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;append&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;vale&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now trying to set values via &lt;code&gt;my_stack[0] = 5&lt;/code&gt; would give an error. And if we decide that we don&#39;t want to use a list to store the items but something else (a linked list, maybe?) we can make this change without changing the interface of &lt;code&gt;Stack&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-13-poodr-chapter8/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Classical inheritance, modules (or mixins) and composition are all great tools with justifiable use cases. They&#39;re all awesome when used in the right context, and they all have the potential to produce hard-to-maintain code when used in the wrong context. The last three chapters have hopefully demonstrated a number of principles that help deciding on which technique to use.&lt;/p&gt;
&lt;p&gt;And if you ever chose the wrong technique, don&#39;t hestitate to refactor to something more suitable!&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 7</title>
		<link href="https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/"/>
		<updated>2021-01-08T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/</id>
		<content type="html">&lt;p&gt;This is the seventh part in my review and reading notes on the Practical Object Oriented Programming book (&lt;a href=&quot;http://www.poodr.com&quot;&gt;www.poodr.com&lt;/a&gt;) by Sandi Metz.&lt;/p&gt;
&lt;p&gt;Now so far it was relatively easy to talk about Python even though the book is written from a Ruby perspective. This chapter is the first big deviation. Modules, in Ruby, are something altogether different from Python modules. They are most closely related to the idea of a &lt;em&gt;mixin&lt;/em&gt; class: A collection of methods that you can add into an existing class. These modules are &lt;em&gt;a bit like&lt;/em&gt; multiple inheritance, so let&#39;s start with a very brief detour on that.&lt;/p&gt;
&lt;h1 id=&quot;multiple-inheritance&quot; tabindex=&quot;-1&quot;&gt;Multiple Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Lots can be written about multiple inheritance, but we try and keep it brief. Multiple inheritance is the concept of a given class having not one, but &lt;em&gt;several&lt;/em&gt;, base classes. Some languages have it (C++, Python) and some don&#39;t (Java, Ruby). Those languages that made the conscious choice not to offer multiple inheritance do so because it comes with &lt;em&gt;lots&lt;/em&gt; of potential for confusion.&lt;/p&gt;
&lt;p&gt;If we recall that inheritance is a form of &lt;em&gt;automated message delegation&lt;/em&gt;, we can immediately see where such confusion comes from: If &lt;code&gt;A&lt;/code&gt; inherits from both &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, then to which class&#39;s method does &lt;code&gt;A&lt;/code&gt; delegate, in what order? This is called the &lt;em&gt;method resolution order&lt;/em&gt;, or MRO. In single-inheritance languages, this is easy to compute: You delegate first to your immediate super-class, then if the super-class doesn&#39;t implement that method either, you look further up along the chain. With multiple inheritance, though, instead of a chain we have a &lt;em&gt;graph&lt;/em&gt;, with potentially multiple paths.&lt;/p&gt;
&lt;h2 id=&quot;ruby-modules&quot; tabindex=&quot;-1&quot;&gt;Ruby Modules &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So how are modules &amp;quot;kind of&amp;quot; like multiple inheritance? They allow your class to automatically delegate messages to these modules (which are &lt;em&gt;not&lt;/em&gt; classes). And how is that different from &lt;em&gt;ordinary&lt;/em&gt; multiple inheritance? Because of the clear distinction between modules and classes, it is always possible to &lt;em&gt;unambiguously&lt;/em&gt; define the method resolution order, without confusion: When calling a method of an object, that object first checks its own methods. Then it checks, in the order of their inclusion, the modules it incorporates (and any modules that those modules in turn might incorporate). If that fails, it will move on to its superclass and check that class&#39;s methods, and the modules included by that class. There is never any &amp;quot;branching&amp;quot; that happens, and the famous &amp;quot;diamond&amp;quot; problem (A inherits from B and C, which in turn both inherit from D) cannot occur.&lt;/p&gt;
&lt;h2 id=&quot;python-multiple-inheritance&quot; tabindex=&quot;-1&quot;&gt;Python Multiple Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python goes a different route. It allows multiple inheritance, and it uses a specific algorithm (called C3) to come up with a method resolution order. The full algorithm is quite complicated, &lt;em&gt;but&lt;/em&gt; I would argue that creating an inheritance graph where the MRO is not immediately obvious should be considered a &lt;em&gt;code smell&lt;/em&gt; anyway. The main thing to take away is that the order matters: &lt;code&gt;class A(B, C)&lt;/code&gt; and &lt;code&gt;class A(C, B)&lt;/code&gt; will behave differently. In the first case, the MRO is &lt;code&gt;A -&amp;gt; B -&amp;gt; C&lt;/code&gt; whereas in the second case it is &lt;code&gt;A -&amp;gt; C -&amp;gt; B&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The author&#39;s goal in this chapter is to explain not just how inheritance works, but also if it makes sense to use it. More on that, too, in the next chapter.&lt;/p&gt;
&lt;h1 id=&quot;understanding-roles&quot; tabindex=&quot;-1&quot;&gt;Understanding Roles &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;In the previous chapter, we saw how inheritance can be used to re-use code by moving the general concepts into an abstract superclass and then having concrete subclasses provide specializations as needed. This type of hierarchy &lt;em&gt;also&lt;/em&gt; brings with it a strong semantic component: The subclasses form an &lt;em&gt;is-a&lt;/em&gt; relationship with the superclass.&lt;/p&gt;
&lt;p&gt;Sometimes, though, you want to share behavior among otherwise unrelated objects, where there is no &lt;em&gt;is-a&lt;/em&gt; relationship. We want to share behavior and re-use code without that semantic coupling that a subclass / superclass relationship involves. Let&#39;s follow along with the author.&lt;/p&gt;
&lt;h2 id=&quot;finding-roles&quot; tabindex=&quot;-1&quot;&gt;Finding Roles &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Objects have a type, defined by what class they&#39;re an instance of. But objects also&lt;br&gt;
play &lt;em&gt;roles&lt;/em&gt;, and a single object might, depending on the context, play many different roles. In the previous &amp;quot;bike shop&amp;quot; examples, a &lt;code&gt;Mechanic&lt;/code&gt; might play the &lt;em&gt;role&lt;/em&gt; of a trip preparer, but it might also play some other roles. So we see that the previously mentioned &lt;em&gt;duck types&lt;/em&gt; are examples of roles: Many otherwise unrelated objects might play the same role if they all implement the same duck type.&lt;/p&gt;
&lt;p&gt;Now with many roles, it happens that there&#39;ll be a corresponding counter-part role: If there&#39;s a &lt;code&gt;Preparer&lt;/code&gt; then there&#39;s (probably) also a &lt;code&gt;Preparable&lt;/code&gt; role: If you recall, the &lt;code&gt;Mechanic&lt;/code&gt; class needed to ask the trip for a list of bicycles. So a &lt;code&gt;Preparable&lt;/code&gt; should have a method like &lt;code&gt;get_bicycles()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The special thing about roles based on duck types is that they are defined &lt;em&gt;purely&lt;/em&gt; by their interface. But it is easy to imagine that there are roles that are more complex and require specific &lt;em&gt;behavior&lt;/em&gt;, not just a specific &lt;em&gt;public interface&lt;/em&gt;. If there&#39;s shared behavior, we want to avoid just repeating it in the code. Think DRY (don&#39;t repeat yourself). So how do we organize this code that represents the shared behavior?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In Ruby, &lt;em&gt;modules&lt;/em&gt; are groups of methods that are independent of class and can be &lt;em&gt;mixed in&lt;/em&gt; to another class.&lt;/li&gt;
&lt;li&gt;In Python, you&#39;d use multiple inheritance, but with certain self-imposed restrictions to avoid creating a tangled mess of a class hierarchy: You would bundle the shared code in a class with &lt;code&gt;Mixin&lt;/code&gt; in its name to signify that it&#39;s meant to be &lt;em&gt;mixed in&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The self-imposed restrictions on multiple inheritance in Python are modeled after the way Ruby modules work: Since a module isn&#39;t a class, you cannot &lt;em&gt;instantiate&lt;/em&gt; a module. In a similar way, a Python Mixin class is not &lt;em&gt;meant&lt;/em&gt; to be instantiated. We&#39;ll see some concrete examples later on.&lt;/p&gt;
&lt;h2 id=&quot;organizing-responsibilities&quot; tabindex=&quot;-1&quot;&gt;Organizing Responsibilities &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here we follow along as the author walks us through another example. I like how she follows the progression of how one might initially tackle a given problem and then discusses how the design can be improved.&lt;/p&gt;
&lt;p&gt;In this example, we&#39;re looking at scheduling, which means we&#39;ll have a &lt;code&gt;Schedule&lt;/code&gt; class, right? Okay, and then this class is responsible for &lt;em&gt;scheduling things&lt;/em&gt;. Different things might have different constraints around being scheduled. In the current example, there&#39;s a certain amount of &lt;em&gt;lead time&lt;/em&gt; involved.&lt;/p&gt;
&lt;p&gt;In a first version, some object asks the &lt;code&gt;Schedule&lt;/code&gt; class if some target object could be scheduled. The &lt;code&gt;Schedule&lt;/code&gt; class then switches on type (uh oh, code smell!) to decide how many lead days to include in the schedule calculation.&lt;/p&gt;
&lt;p&gt;Well, not to worry, we know all about using duck types to remove these type switches: The things we want to schedule should implement the &lt;code&gt;Schedulable&lt;/code&gt; duck type, which means we can &lt;em&gt;ask&lt;/em&gt; them how many lead days they need. No more type switching required.&lt;/p&gt;
&lt;p&gt;But according to the author, that&#39;s still bad design! Here&#39;s the logic:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some &lt;em&gt;instigating object&lt;/em&gt; wants to know if &lt;code&gt;target&lt;/code&gt; is schedulable.&lt;/li&gt;
&lt;li&gt;So why not ask the &lt;code&gt;target&lt;/code&gt; directly? Let objects speak for themselves!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The author uses a great example to show why this is a much better design than using the &lt;code&gt;Schedule&lt;/code&gt; class. I&#39;ll translate it to Python. If you have a python string, you can call all sorts of useful methods on that string: Convert to upper-case, split into multiple strings based on some delimiter, and so on. It would be very un-pythonic (and un-OOD) to have a string just be a dumb (i.e. no useful methods) holder of bytes and move all the string manipulation into a &lt;code&gt;StringUtil&lt;/code&gt; class.&lt;/p&gt;
&lt;p&gt;Great, so how do we go about this? As with classical inheritance, first we&#39;d implement the role &lt;em&gt;concretely&lt;/em&gt; in one of the classes that exhibit that role. So we pick one of the things that we want to be able to schedule, and implement the &lt;code&gt;can_schedule&lt;/code&gt; method there. Then we refactor and move the &lt;em&gt;general&lt;/em&gt; things &lt;em&gt;up&lt;/em&gt; the hierarchy. In Ruby, we&#39;d use a module. In Python, we&#39;d use a Mixin class.&lt;/p&gt;
&lt;p&gt;The &amp;quot;techniques&amp;quot; are the same as with inheritance, really: Use hook methods, promote abstractions up the hierarchy instead of pushing concretions down. And think of Mixins as &amp;quot;behaves as&amp;quot; instead of &amp;quot;is a&amp;quot;.&lt;/p&gt;
&lt;p&gt;How to go about this?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First implement the role concretely in one of the classes that should exhibit the role&lt;/li&gt;
&lt;li&gt;Then refactor to move things &amp;quot;up&amp;quot; the hierarchy.&lt;/li&gt;
&lt;li&gt;In Ruby, use module&lt;/li&gt;
&lt;li&gt;In Python, use multiple inheritance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Use all the same techniques! Hook methods! Promoting abstractions up instead of pushing concretions down.&lt;/p&gt;
&lt;p&gt;Think of mix-ins as &amp;quot;behaves as&amp;quot; instead of &amp;quot;is-a&amp;quot;.&lt;/p&gt;
&lt;p&gt;Now let us conclude this section by writing a Python Mixin that roughly does what the Ruby module in the author&#39;s example does: So we identified that there is a &lt;em&gt;role&lt;/em&gt; for objects to be &lt;code&gt;Schedulable&lt;/code&gt;, which means they should implement the two methods &lt;code&gt;is_scheduled(start_date, end_date)&lt;/code&gt; and &lt;code&gt;can_schedule(start_date, end_date&lt;/code&gt;. But really, for pretty much all the objects playing this role, the &lt;em&gt;behavior&lt;/em&gt; will be generally the same: There are some lead days to take into account and then we just look it up. So we also add a &lt;code&gt;lead_days&lt;/code&gt; method, meant to be overridden by classes who include the mixin. Here&#39;s how it would look:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SchedulableMixin&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# (1)&lt;/span&gt;
    
    &lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@property&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;  &lt;span class=&quot;token comment&quot;&gt;#(2)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__schedule &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
            self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__schedule &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; Schedule&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__schedule
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;can_schedule&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; start_date&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; end_date&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;not&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;is_scheduled&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;start_date &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;lead_days&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; 
                                     end_date&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;#(3)&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;is_scheduled&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; start_date&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; end_date&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;#(4)&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;schedule&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;is_scheduled&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;start_date&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; end_date&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
    
    &lt;span class=&quot;token comment&quot;&gt;## Includers may override: #(5)&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;lead_days&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&#39;s discuss:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1) We add the &amp;quot;Mixin&amp;quot; prefix to make it clear that this isn&#39;t meant to be a standalone base class, even though there are no abstract methods.&lt;/li&gt;
&lt;li&gt;(2) To be schedulable, you need to keep track of when you&#39;ve been scheduled. Moving this &lt;code&gt;Schedule&lt;/code&gt; object &lt;em&gt;into&lt;/em&gt; the mixin puts the overall responsibiltiy of this on the &lt;code&gt;SchedulableMixin&lt;/code&gt; and thus reduces the coupling of classes. Here we use double-underscores to make use of Python&#39;s &amp;quot;name mangling&amp;quot; feature: If we had named the field &lt;code&gt;self._schedule&lt;/code&gt; instead, and if a class that inherits from &lt;code&gt;SchedulableMixin&lt;/code&gt; also happened to have a &lt;code&gt;_schedule&lt;/code&gt; field, we would be running into a name clash! With the double-underscore, Python just renames &lt;code&gt;__schedule&lt;/code&gt; behind the scenes into &lt;code&gt;_SchedulableMixin__schedule_&lt;/code&gt;. So, technically there is still the potential for name clashes if the other class for whatever weird reason also had a field called &lt;code&gt;_SchedulableMixin__schedule_&lt;/code&gt;. But if you use such weird names without good reason you&#39;ve really only got yourself to blame.&lt;/li&gt;
&lt;li&gt;(3) This is the &amp;quot;meat&amp;quot; of the general behavior that all the objects playing the &lt;code&gt;Schedulable&lt;/code&gt; role share: You can schedule a schedulable object if it hasn&#39;t been scheduled during the start date, including any lead time, up until the end date.&lt;/li&gt;
&lt;li&gt;(4) Now we just delegate to the contained &lt;code&gt;Schedule&lt;/code&gt; object (see next chapter for a deep dive into composition).&lt;/li&gt;
&lt;li&gt;(5) In certain languages (Java for example) you can explicitly declare that certain methods may &lt;em&gt;not&lt;/em&gt; be overridden. Both Ruby and Python do not have this feature, so we just use comments to explain to users: &amp;quot;This &lt;code&gt;lead_days&lt;/code&gt; method is what you should override, but the rest is general logic that probably should remain untouched&amp;quot;. Here we use the hook method technique, as introduced in the previous chapter, to allow classes that inherit from this Mixin to provide their own specialization. The design message then is: Every class that inherits from &lt;code&gt;SchedulableMixin&lt;/code&gt; &lt;em&gt;behaves as a&lt;/em&gt; &lt;code&gt;Schedulable&lt;/code&gt;, and they only differ in their number of lead days.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;writing-inheritable-code&quot; tabindex=&quot;-1&quot;&gt;Writing Inheritable Code &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Sharing inherited behavior without introducing undue coupling or hard-to-extend rigid hierarchies requires very specific coding techniques! Let&#39;s take a look at some:&lt;/p&gt;
&lt;h2 id=&quot;recognize-the-antipatterns&quot; tabindex=&quot;-1&quot;&gt;Recognize the Antipatterns &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Your code &lt;em&gt;might&lt;/em&gt; benefit from inheritance if...&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You use a variable like &lt;code&gt;type&lt;/code&gt; or &lt;code&gt;category&lt;/code&gt; or whatever.
&lt;ul&gt;
&lt;li&gt;In this case, classical inheritance might be good! (See also here &lt;a href=&quot;https://refactoring.guru/replace-type-code-with-subclasses&quot;&gt;https://refactoring.guru/replace-type-code-with-subclasses&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;Put common abstraction in base class.&lt;/li&gt;
&lt;li&gt;Provide &lt;em&gt;specializations&lt;/em&gt; in the child classes.&lt;/li&gt;
&lt;li&gt;And remember the Liskov Substitution Principle!&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A &lt;em&gt;sending object&lt;/em&gt; checks class type to decide on what message to send.
&lt;ul&gt;
&lt;li&gt;In this case, all the potential receivers play a common &lt;em&gt;role&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;That &lt;em&gt;role&lt;/em&gt; is a &lt;em&gt;duck type&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;If duck types share &lt;em&gt;behavior&lt;/em&gt; in addition to the interface, realize that via mix-in.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;insist-on-the-abstraction&quot; tabindex=&quot;-1&quot;&gt;Insist on the Abstraction &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The code, both concrete and abstract, that is contained in an abstract superclass must apply to &lt;em&gt;every&lt;/em&gt; class that inherits it. No exceptions. There is a code smell named after this: &lt;a href=&quot;https://refactoring.guru/smells/refused-bequest&quot;&gt;Refused Bequest&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And why is this a bad code smell? Because faulty abstractions lead to ugly hacks and fragile workarounds. Remember the subcalss relationship: If &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt;, then &lt;code&gt;A&lt;/code&gt; &lt;strong&gt;is a&lt;/strong&gt; &lt;code&gt;B&lt;/code&gt;. If &lt;code&gt;A&lt;/code&gt; then overrides one of &lt;code&gt;B&lt;/code&gt;&#39;s methods to, say, &lt;code&gt;raise NotImplementedError&lt;/code&gt; then &lt;code&gt;A&lt;/code&gt; basically says &amp;quot;Yeah I&#39;m not &lt;em&gt;really&lt;/em&gt; a &lt;code&gt;B&lt;/code&gt;&amp;quot;.&lt;/p&gt;
&lt;p&gt;Sometimes the problem can be solved by realizing that in your initial writing of the abstract class you added too much concrete code; code that should better be put into the child classes that actually use it. But sometimes there just isn&#39;t a good abstraction. In that case, don&#39;t use inheritance. You can still avoid code duplication using other techniques, such as composition (next chapter!).&lt;/p&gt;
&lt;h2 id=&quot;honor-the-contract&quot; tabindex=&quot;-1&quot;&gt;Honor the Contract &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A subclass does not just inherit the public interface of its superclass. It also inherits the &lt;em&gt;expected behavior&lt;/em&gt; of such an interface. In a proper class hierarchy, a subclass promises to be &lt;em&gt;substitutable&lt;/em&gt; for its superclass. If &lt;code&gt;A&lt;/code&gt; inherits from &lt;code&gt;B&lt;/code&gt;, then any method that thinks it&#39;s working with a &lt;code&gt;B&lt;/code&gt; should do just fine working with an &lt;code&gt;A&lt;/code&gt;. Think about what would happen if a subclass &lt;em&gt;wasn&#39;t&lt;/em&gt; substitutable. Then every bit of code that works with class &lt;code&gt;B&lt;/code&gt; now has to explicitly check whether you &lt;em&gt;actually&lt;/em&gt; gave it a &lt;code&gt;B&lt;/code&gt; or snuck in an &lt;code&gt;A&lt;/code&gt; instead, and we&#39;re back at being tightly coupled to classes, when the whole point of using inheritance in the first place was to avoid explicit type checks.&lt;/p&gt;
&lt;p&gt;Recall the Liskov substitution principle. A subclass and its methods &lt;em&gt;may&lt;/em&gt; accept broader inputs than the superclass, because then it will &lt;em&gt;definitely&lt;/em&gt; accept the inputs that are valid for the superclass. And it &lt;em&gt;may&lt;/em&gt; return narrower results than the superclass, because then its results will &lt;em&gt;definitely&lt;/em&gt; be valid results of the superclass. That way, there can be no nasty surprises. Here is an example:&lt;/p&gt;
&lt;p&gt;Let&#39;s say we have a class doing some math work on numbers, with a superclass having methods that accept and return integers, both positive and negative. With the principle above in mind, then, we could think of subclasses working with different numbers:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A subclass&#39;s methods could accept floats as well as integers.&lt;/li&gt;
&lt;li&gt;A subclass&#39;s methods might only return &lt;em&gt;positive&lt;/em&gt; integers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But here are some &lt;em&gt;invalid&lt;/em&gt; examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A subclass must not &lt;em&gt;refuse&lt;/em&gt; to accept negative integers!&lt;/li&gt;
&lt;li&gt;The subclass cannot &lt;em&gt;return&lt;/em&gt; floating point numbers!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If a subclass did either of those two things, it could not be substituted for the superclass.&lt;/p&gt;
&lt;p&gt;But &lt;em&gt;honoring the contract&lt;/em&gt; goes further than just making sure that the types of arguments and return values match. It really means: Make sure nobody who is working with your class hierarchy has to ever explicitly check which particular subclass you passed. To quote the author:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;An object should act like it claims to be&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I&#39;ll leave with this counter-example:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;BlackHole&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This class claims that it &lt;em&gt;is a&lt;/em&gt; list, but definitely doesn&#39;t behave like one...&lt;/p&gt;
&lt;h2 id=&quot;use-the-template-method-pattern&quot; tabindex=&quot;-1&quot;&gt;Use the Template Method Pattern &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;We talked about this at length in the previous chapter. This is the best pattern for writing code that is readily inheritable. It forces you to think carefully about what&#39;s abstract and what&#39;s concrete. The abstract part is the &amp;quot;general algorithm&amp;quot; and the concrete part are the specializations.&lt;/p&gt;
&lt;p&gt;In this case, it also helps to make explicit which methods are meant to be overridden (the template methods) and which methods are part of the &amp;quot;stable&amp;quot; abstract algorithm. In some languages, you can use a keyword such as &lt;code&gt;final&lt;/code&gt; to prevent a method from ever being overridden by a subclass, but in Python we can only use comments. (There is a proposal to add such a &lt;code&gt;final&lt;/code&gt; qualifier to Python&#39;s type hints, but remember that type hints have no effect on the running of the Python program; they&#39;re merely annotations and comments for the programmer and some external tools.)&lt;/p&gt;
&lt;h2 id=&quot;preemptively-decouple-classes&quot; tabindex=&quot;-1&quot;&gt;Preemptively Decouple Classes &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If at all possible, avoid writing code that &lt;em&gt;forces&lt;/em&gt; an overriding method to call &lt;code&gt;super()&lt;/code&gt;. This would lead to strong coupling between the super- and subclass. As we have seen in the last chapter, hook methods are the way to go here: They keep the superclass in control of the algorithm, and absolve the subclasses from having to know about when and how to call the super-version.&lt;/p&gt;
&lt;p&gt;One exception to this, I would say, is the &lt;code&gt;__init__&lt;/code&gt; method. In some languages, when you create an instance of a subclass, the constructor of the superclass gets called automatically. This is not the case in Python, and so it&#39;s a very common occurrence that your subclass&#39;s &lt;code&gt;__init__&lt;/code&gt; calls &lt;code&gt;super().__init__()&lt;/code&gt;, although you could also consider using a &lt;code&gt;post_init()&lt;/code&gt; hook method.&lt;/p&gt;
&lt;p&gt;One note about hook methods, though: They only work in &lt;em&gt;shallow&lt;/em&gt; hierarchies, one level deep. If you go deeper, you might have to call &lt;code&gt;super()&lt;/code&gt; after all. This leads us to the next point:&lt;/p&gt;
&lt;h2 id=&quot;create-shallow-hierarchies&quot; tabindex=&quot;-1&quot;&gt;Create Shallow Hierarchies &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A class hierarchy can be shallow or deep, and it can be narrow or wide. The ideal hierarchy, from the point of readability and understandability, is of course shallow and narrow: Only a few child classes, and only one level deep.&lt;/p&gt;
&lt;p&gt;The worst hierarchies are deep and wide. They are too complex to understand and often too rigid in their design. Avoid those!&lt;/p&gt;
&lt;p&gt;What&#39;s still okay are shallow and wide hierarchies. It just means that your one base class has many useful specializations. It should still be relatively easy to reason about such a hierarchy.&lt;/p&gt;
&lt;p&gt;What&#39;s not so okay are deep and narrow hierarchies. According to the author, there&#39;s two issues with them. First, over time they grow wider anyway as we add new classes here and there at different levels of the hierarchy. Second, most people only understand the ends of the hierarchy: The classes at the top and the classes at the bottom, with lots of mystery and confusion in the middle.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2021-01-08-poodr-chapter7/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;The first thing to check with mixins / modules is whether they &lt;em&gt;actually&lt;/em&gt; represent a &lt;em&gt;role&lt;/em&gt; that an object might play. The coding techniques to make mixins and modules successful are the same patterns that make classical inheritance successful. And when an object acquires behavior via inheritance, it should honor the contract implied by that relationship.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 6</title>
		<link href="https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/"/>
		<updated>2020-12-27T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/</id>
		<content type="html">&lt;p&gt;This is the sixth part in my review and reading notes on the Practical Object Oriented Programming book (www.poodr.com) by Sandi Metz.&lt;/p&gt;
&lt;p&gt;So, let&#39;s talk inheritance. It might seem strange that, in a book about object oriented design, inheritance only shows up this late in the game. Isn&#39;t inheritance &lt;em&gt;the&lt;/em&gt; OG object oriented feature? Well, let&#39;s see!&lt;/p&gt;
&lt;p&gt;Some recap thoughts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In a well-designed application, code is easy to reuse, and is also actively being reused to solve different problems.&lt;/li&gt;
&lt;li&gt;If your classes are small, have minimum context, have their dependencies injected into them, and furthermore have clear public interfaces, then they&#39;re already super reusable!&lt;/li&gt;
&lt;li&gt;So where does that leve inheritance?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I appreciate the authors goal: There&#39;s a &lt;em&gt;know how&lt;/em&gt; to using inheritance, and there&#39;s also the (even more important) question of &lt;em&gt;whether&lt;/em&gt; to use it at all.&lt;/p&gt;
&lt;h1 id=&quot;understanding-classical-inheritance&quot; tabindex=&quot;-1&quot;&gt;Understanding Classical Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Without getting philosophical about inheritance and taxonomies and &amp;quot;is-a&amp;quot; relationships, at its practical core inheritance is about message delegation: If an object receives a message, it either deals with the message itself, or it delegates the message to another object. All inheritance does is say: &lt;em&gt;Any&lt;/em&gt; message you don&#39;t understand yourself, please delegate to the class you&#39;re inheriting from.&lt;/p&gt;
&lt;p&gt;But leaving it at this level is dangerous. There are certainly &lt;em&gt;misuses&lt;/em&gt; of inheritance that create unnecessary coupling and rigid structures that make your code hard to maintain and extend!&lt;/p&gt;
&lt;h1 id=&quot;recognize-where-to-use-inheritance&quot; tabindex=&quot;-1&quot;&gt;Recognize Where To Use Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;So here the author gives a good example where inheritance will be useful; but also discusses &lt;em&gt;how&lt;/em&gt; we go about recognizing this in general, and how we then go about &lt;em&gt;introducing&lt;/em&gt; inheritance. One main takeaway right away: It&#39;s pretty much &lt;em&gt;never&lt;/em&gt; a good idea to &lt;em&gt;start&lt;/em&gt; with some preconceived idea of what the inheritance structure (the family tree, so to speak) of your classes &lt;em&gt;should&lt;/em&gt; look like. Let the concrete objects you have be your guide!&lt;/p&gt;
&lt;h2 id=&quot;starting-with-a-concrete-class&quot; tabindex=&quot;-1&quot;&gt;Starting with a Concrete Class &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here the author just introduces a concrete class that does a concrete thing. A bicycle, in this case, that has some info about its tires and about what sort of spare parts it needs.&lt;/p&gt;
&lt;h2 id=&quot;embedding-multiple-types&quot; tabindex=&quot;-1&quot;&gt;Embedding Multiple Types &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In this chapter, we introcuce some extra behavior, some twist, in our concrete class: We want to add something that is &lt;em&gt;almost&lt;/em&gt; like the thing we already have. This happens &lt;em&gt;all&lt;/em&gt; the time! It is at this point very tempting to just bolt that extra stuff onto the class we already have. (Here it is again, that strong focus on classes that are already there!)&lt;/p&gt;
&lt;p&gt;Often, this sort of bolting-on involves adding a switch to our class. In this case, the &lt;code&gt;Bicycle&lt;/code&gt; class gets a field that says whether a particular instance is a road bike or a mountain bike. And then the class&#39;s methods involve checking what that type field is set to.&lt;/p&gt;
&lt;p&gt;This is bad! It is just like the antipattern (code smell) from the previous section. Just as we shouldn&#39;t switch on an object&#39;s class so we shouldn&#39;t switch on a class&#39;s &amp;quot;type&amp;quot; or &amp;quot;style&amp;quot; variable: It leads to rigid code that&#39;s awkward to extend, and it also leads to lots of duplications as our class will be littered with these type checks.&lt;/p&gt;
&lt;p&gt;In more direct terms, adding such a type or style field violates the single responsibility principle, because with that switch we literally state that our class does either one thing or another thing.&lt;/p&gt;
&lt;h2 id=&quot;finding-the-embedded-types&quot; tabindex=&quot;-1&quot;&gt;Finding the Embedded Types &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Such a type check is really a strong hint that we should be dealing with two different classes. It may very well be the case that these classes share lots of behavior, but they also differ across some aspects, as expressed by that &lt;code&gt;style&lt;/code&gt; variable. This is exactly the situation where inheritance &lt;em&gt;can&lt;/em&gt; be useful.&lt;/p&gt;
&lt;h2 id=&quot;choosing-inheritance&quot; tabindex=&quot;-1&quot;&gt;Choosing inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The automated delegation that happens with inheritance means that a subclass is everything the superclass is &lt;em&gt;and then some&lt;/em&gt;. The subclass &lt;em&gt;acquires&lt;/em&gt; the complete public interface of its superclass. This brings with it certain &lt;em&gt;responsibilities&lt;/em&gt;: The superclass&#39;s public interface represents a certain contract; certain promises about what the public interface achieves. Your subclass must honor this contract!&lt;/p&gt;
&lt;h2 id=&quot;misapplying-inheritance&quot; tabindex=&quot;-1&quot;&gt;Misapplying Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before we see how &lt;em&gt;good&lt;/em&gt; inheritance looks like, the author shows us how &lt;em&gt;bad&lt;/em&gt; inheritance looks like. The hidden culprit here is, again, an overreliance on existing classes:&lt;/p&gt;
&lt;p&gt;The example had a concrete class &lt;code&gt;Bicycle&lt;/code&gt; and then has &lt;code&gt;MountainBike&lt;/code&gt; inherit directly from this concrete class. That led to a number of issues, becase the original bicycle class has behavior that &lt;em&gt;doesn&#39;t make sense&lt;/em&gt; for a mountain bike (things like handlebar tape, apparently). There&#39;s a code smell with the name &lt;em&gt;Refused Bequest&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Sub-classes get to inherit the methods and data of their parents. But, what if they don&#39;t want or need what they are given? They are given all these great gifts and pick just a few to play with.
-- Martin Fowler, Refactoring: Improving the Design of Existing Code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Inheritance is all-or-nothing. By adding methods to your class&#39;s public interface, you &lt;em&gt;promise&lt;/em&gt; that your class will &lt;em&gt;behave as expected&lt;/em&gt; when someone calls these methods!&lt;/p&gt;
&lt;p&gt;As we will see below, writing classes that are &amp;quot;open for extension&amp;quot; (via inheritance) requires special care and techniques to reduce the risk of ending up with a strongly coupled mess.&lt;/p&gt;
&lt;h2 id=&quot;finding-the-abstraction&quot; tabindex=&quot;-1&quot;&gt;Finding the Abstraction &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given that subclasses are &lt;em&gt;specializations&lt;/em&gt; of their superclasses, any object that expects to be working with an instance of the superclass should be able to work instead with an instance of the subclass &lt;em&gt;without knowing that it is dealing with a subclass&lt;/em&gt;. This is the Liskov substitution principle, named after Barbara Liskov.&lt;/p&gt;
&lt;h3 id=&quot;the-two-main-rules-of-inheritance&quot; tabindex=&quot;-1&quot;&gt;The Two Main Rules of Inheritance &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Inheritance can only work if these two things are true:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If &lt;code&gt;Child&lt;/code&gt; inherits from &lt;code&gt;Parent&lt;/code&gt;, then &lt;code&gt;Child&lt;/code&gt; &lt;em&gt;really&lt;/em&gt; must be a &lt;em&gt;specialization&lt;/em&gt; of &lt;code&gt;Parent&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;You must use the correct coding techqniues. More on that later.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In terms of specializations, here is a quick example of this principle gone wrong: If you see your inheritance tree as a sort of taxonomy where the child classes have an &amp;quot;is-a&amp;quot; relationship with the parent classes, you risk violating the &amp;quot;specialization&amp;quot; principle. For example, a &lt;code&gt;Square&lt;/code&gt; &lt;em&gt;is a&lt;/em&gt; &lt;code&gt;Rectangle&lt;/code&gt; but code that expects a &lt;code&gt;Rectangle&lt;/code&gt; to work with might &lt;em&gt;not&lt;/em&gt; work with a &lt;code&gt;Square&lt;/code&gt;, because a square is a &lt;em&gt;restricted&lt;/em&gt; rather than an &lt;em&gt;extended&lt;/em&gt; version of a rectangle.&lt;/p&gt;
&lt;h2 id=&quot;creating-an-abstract-superclass&quot; tabindex=&quot;-1&quot;&gt;Creating an Abstract Superclass &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So far we discussed why it is dangerous to just directly inherit from a concrete class. It is better to first find what the two concrete classes would have in common and extract that into a superclass. This class may very well be &lt;em&gt;abstract&lt;/em&gt;. Such abstract classes &lt;em&gt;exist&lt;/em&gt; to be subclassed.&lt;/p&gt;
&lt;p&gt;Also, if you remember the discussion from chapter 3, it is always better if classes that have many dependencies are more on the abstract side, as abstract qualities are less likely to change than concrete qualities.&lt;/p&gt;
&lt;p&gt;One note for those of us who are over-eager: Resist the temptation to &lt;em&gt;start&lt;/em&gt; your coding with a big class hierarchy design up front. You almost never get it right. And in particular, don&#39;t create an abstract class if there would currently be only one concrete subclass. That would be premature, because you haven&#39;t yet seen on which dimension the other concrete classes would differ, and on which dimensions they would share behavior! It is much better to wait until more information arrives.&lt;/p&gt;
&lt;p&gt;And the author says that even with &lt;em&gt;two&lt;/em&gt; examples of concrete classes that &lt;em&gt;could&lt;/em&gt; quite reasonably put some shared behavior into a common superclass, it might be premature to do so! Often best to wait for &lt;em&gt;three&lt;/em&gt; examples. I&#39;ve heard a similar &amp;quot;three strikes&amp;quot; rule for other occasions where you would want to remove duplication. There&#39;s a tension here between improving the design &lt;em&gt;right now&lt;/em&gt; but risking getting it wrong versus living with a worse design &lt;em&gt;for now&lt;/em&gt; but then having a better design once more information arrives. Check out the relevant chapter!&lt;/p&gt;
&lt;h2 id=&quot;promoting-abstract-behavior&quot; tabindex=&quot;-1&quot;&gt;Promoting Abstract Behavior &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Okay, so now for the sake of example we &lt;em&gt;do&lt;/em&gt; create an abstract class for &lt;code&gt;Bicycle&lt;/code&gt; with the idea that &lt;code&gt;RoadBike&lt;/code&gt; and &lt;code&gt;MountainBike&lt;/code&gt; will be subclcasses. We could go about this &lt;em&gt;refactoring&lt;/em&gt; in two ways:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We could add an empty class &lt;code&gt;RoadBike&lt;/code&gt; that inherits from &lt;code&gt;Bicycle&lt;/code&gt;. Then we &lt;em&gt;push down&lt;/em&gt; the concrete stuff from &lt;code&gt;Bicycle&lt;/code&gt; into &lt;code&gt;RoadBike&lt;/code&gt; and leave only the abstract stuff behind.&lt;/li&gt;
&lt;li&gt;Or we could rename &lt;code&gt;Bicycle&lt;/code&gt; to &lt;code&gt;RoadBike&lt;/code&gt; and add an empty abstract class &lt;code&gt;Bicycle&lt;/code&gt; from which &lt;code&gt;RoadBike&lt;/code&gt; inherits. Then we &lt;em&gt;push up&lt;/em&gt; all the general abstract stuff from the concrete class to the abstract class.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Both sound innocent enough, but the author beautifully explains why one way leads to disaster! It boils down to the question &amp;quot;Well, what if you&#39;re wrong?&amp;quot;. If you pick option 2 and &lt;em&gt;push up&lt;/em&gt; the abstract code, you might &lt;em&gt;miss&lt;/em&gt; some of the abstract code. If some abstract behavior is missing in the base class, it will need to be &lt;em&gt;duplicated&lt;/em&gt; in all the subclasses, and this duplication will be easy to spot and remedy.&lt;/p&gt;
&lt;p&gt;If, on the other hand, you pick option 1 and &lt;em&gt;push down&lt;/em&gt; the concrete code, and you miss some of the concrete stuff, then your supposedly general, abstract, class is now &lt;em&gt;polluted&lt;/em&gt; with concrete behavior. Other subclasses might start to depend on it, or they might have to &amp;quot;deal&amp;quot; with it much in the way that &lt;code&gt;MountainBike&lt;/code&gt;, in the &amp;quot;bad&amp;quot; version, had to deal with concrete road bike behavior that it didn&#39;t need or want!&lt;/p&gt;
&lt;h2 id=&quot;separating-abstract-from-concrete&quot; tabindex=&quot;-1&quot;&gt;Separating Abstract from Concrete &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Just a quick note here: Sometimes you can directly push a method up in the hierarchy,
but as the author explains with an example, sometimes you first have to pry apart the abstract and the concrete. Another argument for keeping your methods short and single-purpose! The top-level methods might be more on the abstract side and the lower-level methods called by them might be more on the concrete side. That allows for easy promotion up the class hierarchy. If you had just smashed everything into a single method, you might miss this opportunity!&lt;/p&gt;
&lt;h2 id=&quot;using-the-template-method-pattern&quot; tabindex=&quot;-1&quot;&gt;Using the Template Method Pattern &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Another benefit of using small methods with single purpose is that your subclasses can override them, with great precision, to provide specialized behavior.&lt;/p&gt;
&lt;h1 id=&quot;managing-coupling-between-superclasses-and-subclasses&quot; tabindex=&quot;-1&quot;&gt;Managing Coupling Between Superclasses and Subclasses &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Now it gets interesting and this often gets overlooked when using inheritance!&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inheritance introduces coupling!&lt;/li&gt;
&lt;li&gt;This coupling must be carefully managed, just like any other coupling!&lt;/li&gt;
&lt;li&gt;Ideally this coupling will not be overly tight!&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;understanding-coupling&quot; tabindex=&quot;-1&quot;&gt;Understanding Coupling &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here&#39;s a special coupling that is unique to inheritance: If you&#39;ve used inheritance, you have certainly come across this situation: A subclass overrides a method of the superclass but still relies on the superclass&#39;s implementation of that method, and it gets there via a call to
&lt;code&gt;super&lt;/code&gt;. Here is an example:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Superclass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_superclass_init_stuff&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subclass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Superclass&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_some_special_subclass_init_stuff&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token builtin&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;__init__&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks innocent enough, but it might also show up in more complicated methods! The problem here is that we introduce a certain coupling: We need to know &lt;em&gt;when&lt;/em&gt; and &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;if&lt;/em&gt; to call the various methods of &lt;code&gt;super&lt;/code&gt; in order to provide our specializations! Our subclass, when sending messages to &lt;code&gt;super&lt;/code&gt;, basically says: &amp;quot;I know the &lt;em&gt;algorithm&lt;/em&gt;&amp;quot;. But that knowledge belongs in the superclass!&lt;/p&gt;
&lt;h2 id=&quot;decoupling-subclasses-using-hook-methods&quot; tabindex=&quot;-1&quot;&gt;Decoupling Subclasses Using Hook Methods &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If the superclass controls the algorithm, it must allow the subclasses to provide specialized behavior in certain predefined places. This is achieved via hook methods. In the example above, we would rewrite it like so:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Superclass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_superclass_init_stuff&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;post_init&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;post_init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;pass&lt;/span&gt;
	
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Subclass&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Superclass&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;post_init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_some_special_subclass_init_stuff&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt;init_args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, &lt;code&gt;post_init&lt;/code&gt; is a &lt;em&gt;hook method&lt;/em&gt;. The superclass decides when in the init process it gets called, and it provides a default implementation that does nothing. The subclass overrides it to provide its specialization.&lt;/p&gt;
&lt;p&gt;This approach is also called the &lt;em&gt;template method pattern&lt;/em&gt;. The superclass&#39;s
responsibility is to know the abstract concept of what needs to happen, i.e.,
what methods need to be called. The subclasses are responsible for filling in
the blanks, without having to know exactly where in the algorithm these blanks
are.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-27-poodr-chapter6/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Main takeaways: Inheritance works best if there is some &lt;em&gt;stable abstraction&lt;/em&gt;
where you have at least &lt;em&gt;three&lt;/em&gt; concrete examples (to really nail down what the
common abstraction should be). Using the template method pattern and hook
methods means that your subclasses can fully focus on providing their
specializations without having to know the abstract algorithm of your
superclass.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 5</title>
		<link href="https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/"/>
		<updated>2020-12-03T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/</id>
		<content type="html">&lt;p&gt;This is the fifth part in my review and reading notes on the Practical Object Oriented Programming book (www.poodr.com) by Sandi Metz.&lt;/p&gt;
&lt;p&gt;In the last chapter, we learned how &lt;em&gt;messages&lt;/em&gt; are at the heart of design, and that messages define the &lt;em&gt;public interface&lt;/em&gt; of an object. Combining these two ideas leads to some interesting design consideration, and at the core of this chapter is the concept of &lt;strong&gt;duck typing&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;What &lt;em&gt;is&lt;/em&gt; a &lt;strong&gt;Duck Type&lt;/strong&gt;? Let&#39;s begin with where the name comes from. There&#39;s an old saying that says&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If it quacks like a duck and walks like a duck, it&#39;s a duck.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What does that mean in the context of programming? Well, consider this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python has no static types, and no type checking in, e.g., method signatures.&lt;/li&gt;
&lt;li&gt;If you have a message to send, you can send it to any object that implements that message, regardless of the class&#39;s actual type!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And the point of all this? We replace a dependency on class with a dependency on messages:&lt;/p&gt;
&lt;p&gt;Recall our &lt;code&gt;job_helper&lt;/code&gt; example: The first iteration had class &lt;code&gt;A&lt;/code&gt; with &lt;em&gt;explicit&lt;/em&gt; dependency on &lt;em&gt;class&lt;/em&gt; &lt;code&gt;B&lt;/code&gt;. After using dependency injection, class &lt;code&gt;A&lt;/code&gt; instead depended on being passed &lt;em&gt;some&lt;/em&gt; object that it could send the &lt;code&gt;process&lt;/code&gt; message to. That job helper object is passed into the &lt;code&gt;__init__&lt;/code&gt;, and no type checking takes place.&lt;/p&gt;
&lt;p&gt;And why is this better? Because it is more &lt;em&gt;flexible&lt;/em&gt;. There is less coupling, and the code is ready for change.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; The following code would be very un-pythonic:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;assert&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;job_helper&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		
	&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of a sudden we&#39;re back with having class &lt;code&gt;A&lt;/code&gt; explicitly depend on class &lt;code&gt;B&lt;/code&gt;, and making some unreasonable demands: Now the only way to pass a &lt;code&gt;job_helper&lt;/code&gt; into class &lt;code&gt;A&lt;/code&gt; is to pass an instance of class &lt;code&gt;B&lt;/code&gt; into it. If we want to modify some behavior by passing a different class in, that class now needs to &lt;em&gt;inherit&lt;/em&gt; from &lt;code&gt;B&lt;/code&gt;, creating even more coupling.&lt;/p&gt;
&lt;p&gt;If you &lt;em&gt;absolutely&lt;/em&gt; need to exert this type of control, pick a statically typed language where you don&#39;t have to manually add boilerplate type checking code. As the autor writes, users of an object &lt;em&gt;need not&lt;/em&gt; and &lt;em&gt;should not&lt;/em&gt; be concerned about its class.&lt;/p&gt;
&lt;p&gt;Duck typing essentially means: An object is what its interface says it is. Which means a single object can implement many different interfaces, and an application can contain many interfaces that cut across classes.&lt;/p&gt;
&lt;p&gt;So let&#39;s see what that means&lt;/p&gt;
&lt;h2 id=&quot;overlooking-the-duck&quot; tabindex=&quot;-1&quot;&gt;Overlooking the Duck &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In this section, we follow along as the author shows how you quickly end up with messy, coupled, code if you happily code away and &lt;em&gt;miss&lt;/em&gt; where there could be a &lt;em&gt;duck type&lt;/em&gt; hiding among your objects.&lt;/p&gt;
&lt;p&gt;The example is quite instructive, and the code that the author calls ugly is indeed a well-known &lt;em&gt;code smell&lt;/em&gt;: Having a &lt;code&gt;switch&lt;/code&gt; statement (or an &lt;code&gt;if-else-if&lt;/code&gt; block) that checks an object&#39;s type and then sends a different message based on that object&#39;s type.&lt;/p&gt;
&lt;p&gt;If you are overly focused on your existing objects, it is dangerously easy to arrive at such smelly code: You realize that your class &lt;code&gt;A&lt;/code&gt; might reasonably collaborate with either class &lt;code&gt;B&lt;/code&gt; or class &lt;code&gt;C&lt;/code&gt;, but the message you have to send in either case is different, so you do something like&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;helper&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_message&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;helper&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; C&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_other_message&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Why is this a code smell? Because it makes your code hard to extend and introduces a strong coupling to type. If you find that yet another class &lt;code&gt;D&lt;/code&gt; could be a good collaborator, you have to go to each and every of your &lt;code&gt;if-elif&lt;/code&gt; blocks and add that code, duplicating a lot of knowledge in the process.&lt;/p&gt;
&lt;p&gt;Remember, too, that in our list of basic dependencies, we had &amp;quot;knowing the name of a message to send&amp;quot;. If every single of our potential collaborators requires a different message to be sent, we end up with &lt;em&gt;lots&lt;/em&gt; of these dependencies.&lt;/p&gt;
&lt;h2 id=&quot;finding-the-duck&quot; tabindex=&quot;-1&quot;&gt;Finding the Duck &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So how do we prevent ending up with messy class-dependent code? It&#39;s actually quite straightforwad and rests on a few simple observations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Our smelly code needs the type switching because we need to send a different message to each potential collaborating class based on its underlying type.&lt;/li&gt;
&lt;li&gt;So if we &lt;em&gt;could&lt;/em&gt; somehow send the &lt;em&gt;same&lt;/em&gt; message regardless of underlying class, there&#39;d be no need for this messy switching!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;But what message to send? A few more observations:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Your class should have a single responsibility, and therefore:&lt;/li&gt;
&lt;li&gt;Its methods should have a single goal in service of that responsibility.&lt;/li&gt;
&lt;li&gt;Therefore, your class&#39;s &lt;em&gt;collaborators&lt;/em&gt; arrive at the class (or the method) in service of that goal!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;No matter the collaborator&#39;s actual underlying class and thus overall responsibility, it arrives at your class or method with a single job: Help fulfill the class&#39;s or method&#39;s goal!&lt;/p&gt;
&lt;p&gt;And there&#39;s your duck type. In the authors example, we have a &lt;code&gt;Trip&lt;/code&gt; that needs to be &lt;code&gt;prepare&lt;/code&gt;&#39;d. A number of classes arrive to help it do that, including a &lt;code&gt;Mechanic&lt;/code&gt;, a &lt;code&gt;TripCoordinator&lt;/code&gt; and a &lt;code&gt;Driver&lt;/code&gt;. No matter what a Mechanic or a Trip Coordinator or a Driver &lt;em&gt;generally&lt;/em&gt; does, they arrive at the &lt;code&gt;prepare&lt;/code&gt; method with one goal: Help prepare the trip. Therefore, they should all implement a &lt;code&gt;prepare_trip()&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;In a statically typed language such as Java, you would now explicitly &lt;em&gt;declare&lt;/em&gt; an &lt;em&gt;interface&lt;/em&gt; like so&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Preparer&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;prepare_trip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Trip&lt;/span&gt; trip&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then you would explicitly state that your various classes &lt;em&gt;implement&lt;/em&gt; this interface&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Mechanic&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Prepapre&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;prepare_trip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Trip&lt;/span&gt; trip&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// Specific prepare stuff for Mechanic&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the trip class&#39;s prepare method would explicitly ask for a list of preparers:&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Trip&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;prepare&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Preparer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; preparers&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;// Iterate over preparers and call their prepare_trip method&lt;/span&gt;
	&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In a dynamically typed language, however, there is no need to explicitly create and define these interfaces. But just because you did not explicitly write down that there&#39;s such a thing as a &lt;code&gt;Preparer&lt;/code&gt; does not mean such a type is not hiding in your application.&lt;/p&gt;
&lt;p&gt;At this point you might object: What if the different preparers need to &lt;em&gt;know&lt;/em&gt; different things about the trip? In the pre-duck-type&#39;d version, we&#39;d have &lt;code&gt;prepare_bicycle(bike)&lt;/code&gt; and maybe
&lt;code&gt;fill_up_vehicle(vehicle)&lt;/code&gt; and &lt;code&gt;buy_food(customer)&lt;/code&gt;. Now we want to just send &lt;code&gt;prepare_trip&lt;/code&gt; each time.&lt;/p&gt;
&lt;p&gt;The message sequence diagrams in the book show the answer: To prepare a trip, we send the &lt;code&gt;prepare_trip&lt;/code&gt; message to our preparers, and the various implementations of &lt;code&gt;prepare&lt;/code&gt; then send messages (queries, to be specific) back to the trip object: The mechanic asks for the bikes, the trip coordinator asks for the customers, and so on. This requires of course that &lt;code&gt;Trip&lt;/code&gt; has a reasonable public interface that grants access to whatever the other collaborators need to know, and one should take care to follow all the good rules of interface design as discussed in the previous chapter.&lt;/p&gt;
&lt;h2 id=&quot;consequences-of-duck-typing&quot; tabindex=&quot;-1&quot;&gt;Consequences of Duck Typing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Let&#39;s quote Sandi directly with this great bit:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The ability to tolerate ambiguity about the class of an object is the hallmark of a confident designer. Once you begin to treat your objects as if they are defined by their behavior rather than by their class, you enter into a new realm of expressive flexible design.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As you rework your design, removing dependencies on &lt;em&gt;concrete&lt;/em&gt; classes and instead introducing duck types, you move from the concrete to the abstract. This might &lt;em&gt;initially&lt;/em&gt; be harder to understand, but such code is &lt;em&gt;much&lt;/em&gt; easier to change and extend.&lt;/p&gt;
&lt;p&gt;The one drawback, so far, of introducing the duck type is that it is so ephemeral. When you rely on concrete classes, you can go to the implementation of the concrete class and see what it does. But in the example of the &lt;code&gt;Preparer&lt;/code&gt;, there is no definite place you can go to see what &lt;code&gt;Preparer.prepare_trip&lt;/code&gt; does. More on that later in this post (and in the book, of course.)&lt;/p&gt;
&lt;h3 id=&quot;quick-side-note-python-s-magic-methods&quot; tabindex=&quot;-1&quot;&gt;Quick Side Note: Python&#39;s Magic Methods &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;To see great use of duck typing in action, consider the way Python let&#39;s you control how &lt;em&gt;your&lt;/em&gt; objects should be... printed, copied, iterated over etc:&lt;/p&gt;
&lt;p&gt;Any class that implements &lt;code&gt;__len__&lt;/code&gt; and &lt;code&gt;__getitem__()&lt;/code&gt; for integer indices is considered by Python to be a &lt;em&gt;Sequence&lt;/em&gt;. No need to explicitly declare that your class implements some &lt;code&gt;Sequence&lt;/code&gt; interface. And any piece of code that expects an object over which it can iterate, or whose elements it can access via an index, will work seemlessly with your class.&lt;/p&gt;
&lt;h1 id=&quot;writing-code-that-relis-on-ducks&quot; tabindex=&quot;-1&quot;&gt;Writing Code that Relis on Ducks &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;The implementation of a duck type itself is pretty easy. The hard part is in recognizing where and when you should be using one. So now the author discusses a few common patterns to look out for.&lt;/p&gt;
&lt;h2 id=&quot;recognizing-hidden-ducks&quot; tabindex=&quot;-1&quot;&gt;Recognizing Hidden Ducks &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here the author again emphasizes that &lt;em&gt;switching&lt;/em&gt; on class type is a bad code smell. Say you have a variable that could be one of several different types. As mentioned above, you need to then take a step back and ask: Why do I have this variable here in the first place? It arrived at your class, at your method, for a specific purpose, and &lt;em&gt;that&lt;/em&gt; purpose informs the message you &lt;em&gt;should&lt;/em&gt; be sending.&lt;/p&gt;
&lt;p&gt;This warning against switching on type also extends to switching on implemented methods: Imagine some horribly inconsistent API where you want to turn an object into a string and have to check individually whether your object implements &lt;code&gt;to_string&lt;/code&gt; or &lt;code&gt;toString&lt;/code&gt; or &lt;code&gt;convert_to_string&lt;/code&gt; and then call that. An obvious eample of a missed duck type!&lt;/p&gt;
&lt;h2 id=&quot;placing-trust-in-your-ducks&quot; tabindex=&quot;-1&quot;&gt;Placing Trust in Your Ducks &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Flexible applications are built on objects that operate on trust; it is your job to make your objects trustworthy.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Use the code smells mentioned above to find the missing duck: What does the offending code &lt;em&gt;really&lt;/em&gt; want? Then define a duck type that does just that. Implement it in the relevant classes and enjoy the clean interface!&lt;/p&gt;
&lt;p&gt;What follows in the book are a few rather short sections discussing a few more fine points. Maybe it&#39;s enough to briefly summarize them:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Because a duck type does not concrentely exist in the form of an explicitly defined interface, it is important to document and test their interface appropriately. More on that in Chapter 9.&lt;/li&gt;
&lt;li&gt;Sometimes, duck types need to share behavior instead of just their interfaces. This is discussed in Chapter 7.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;quick-side-note-none-type&quot; tabindex=&quot;-1&quot;&gt;Quick Side Note: None Type &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As an example of a type check that &lt;em&gt;is&lt;/em&gt; okay, the author gives the example where some object could be either of a certain class type, or it could be &lt;code&gt;None&lt;/code&gt; (&lt;code&gt;NilClass&lt;/code&gt; in the Ruby example). If that other type is a basic type, then we&#39;re in a situation where the classes we now depend on (say, &lt;code&gt;NoneType&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;) are much more stable than our own class. It is then okay to depend on it.&lt;/p&gt;
&lt;p&gt;I would like to add a thought here, though: If your code is littered with checks for something being &lt;code&gt;None&lt;/code&gt;, it might be better to use a design pattern called &lt;em&gt;Null Object&lt;/em&gt;, that is, having an explicit class that represents some other class not being there:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; this_object &lt;span class=&quot;token keyword&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	do_the_thing_where_it_is_none&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	this_object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something_fun&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;could be transformed to:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;this_object&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something_fun&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;as long as we have&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;FunObjectNullType&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_something_fun&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token comment&quot;&gt;# Actually do the thing where it&#39;s None&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That way, the responsibility of checking for &lt;code&gt;None&lt;/code&gt; everywhere is removed from the client code and instead moved to a specific place: This class then has a clear, single, responsibility: Deal with some sort of default behavior.&lt;/p&gt;
&lt;h2 id=&quot;conquering-fear-of-duck-typing&quot; tabindex=&quot;-1&quot;&gt;Conquering Fear of Duck Typing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A great chapter! The message ultimately boils down to: If you are writing in a dynamically typed language (Ruby, Python, ...) and try to &lt;em&gt;force&lt;/em&gt; it to behave like a statically typed language (Java, C#, ...) you get the &lt;em&gt;worst&lt;/em&gt; of both worlds.&lt;/p&gt;
&lt;p&gt;This section isn&#39;t meant to be a discussion of which sort of typing is &lt;em&gt;better&lt;/em&gt;. The answer to that will very much depend on your particular situation and preferences. Both approaches undeniably have their benefits and their trade-offs.&lt;/p&gt;
&lt;p&gt;Think about it like this: For a particular home improvement project, you might be best off using nails. For another project, screws will be better. For some, it will be purely a matter of taste. But no matter which you choose, once you have made the choice you better use the right tool associated. Don&#39;t pick screws for your project and then bash them in with a hammer.&lt;/p&gt;
&lt;h3 id=&quot;subverting-duck-types-with-static-typing&quot; tabindex=&quot;-1&quot;&gt;Subverting Duck Types with Static Typing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Just as a recap: In static typic, each and every variable, method argument, and method return value have a single type, and you must explicitly declare what that type is: &amp;quot;This variable shall be a string, and this variable shall be a floating point number and this method returns an instance of &lt;code&gt;SomeClass&lt;/code&gt;&amp;quot;. With dynamic typing, you &lt;em&gt;don&#39;t&lt;/em&gt; do any of that.&lt;/p&gt;
&lt;p&gt;Quick side note: Python has recently introduced type &lt;em&gt;hints&lt;/em&gt;. It might &lt;em&gt;look&lt;/em&gt; like static typing on the surface, but it is not. These hints are purely meant as a bit of documentation and as means for your IDE to show useful parameter hints. The python runtime itself will not care one bit whether you pass a floating point number into a method whose argument had a &lt;code&gt;str&lt;/code&gt; type hint.&lt;/p&gt;
&lt;p&gt;Some people are so uncomfortable with dynamic typing that they hack static typing into the language. Their code is littered with &lt;code&gt;isinstance&lt;/code&gt; checks, but doing so subverts the power of dynamic typing. You cannot write beautifully flexible code with duck typing if your code fails when &amp;quot;the wrong type&amp;quot; arrives.&lt;/p&gt;
&lt;p&gt;Another Python side note: With Python&#39;s Abstract Base Class module, you can define an &lt;em&gt;abstract&lt;/em&gt; class that merely specifies the interface of your duck type. You can then implement the &lt;code&gt;__subclasshook__&lt;/code&gt; class-method where &lt;em&gt;you&lt;/em&gt; get to control how a type check against your abstract base class is performed. For a duck type, this would just be about checking whether certain methods are implemented. This technique has indeed the potential to give you the best of both worlds: Duck typing because your concrete classes don&#39;t need to inherit from any particular base class, and type checking in a place where you think you &lt;em&gt;absolutely&lt;/em&gt; need it. That being said, strongly consider whether you &lt;em&gt;really&lt;/em&gt; need to put type checks into your code.&lt;/p&gt;
&lt;h3 id=&quot;static-versus-dynamic-typing&quot; tabindex=&quot;-1&quot;&gt;Static versus Dynamic Typing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here we get a fair comparison of the benefits of either static or dynamic typing. Note though that these benefits depend on certain assumptions. I don&#39;t think I need to recite this section here. It&#39;s pretty straightforward.&lt;/p&gt;
&lt;h3 id=&quot;embracing-duck-typing&quot; tabindex=&quot;-1&quot;&gt;Embracing Duck Typing &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A great discussion: Some of the perceived &amp;quot;dangers&amp;quot; of dynamic typing are not actually a big deal. One oft-cited benefit of static typing is that the &lt;em&gt;compiler&lt;/em&gt; will catch (some, but certainly not all. Or why else would Java need a &lt;code&gt;NullPointerException&lt;/code&gt;?) type errors at compile time, which is better than your program suddenly crashing at run time.&lt;/p&gt;
&lt;p&gt;Technically this is true, but according to the author, this great big boogeyman of runtime type errors is greatly exaggerated. Yes, a dynamically typed language puts the burden on you to pass in objects that respond to the message they&#39;re being sent. But if your program is designed well, using trustworthy and expressive code, such type errors should be exceedingly rare. If that is the case, static typing may very well be the equivalent to Springfield&#39;s Bear Patrol: https://www.youtube.com/watch?v=fm2W0sq9ddU&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-12-03-poodr-chapter5/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Judge objects by what they do, not by who they are!&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 4</title>
		<link href="https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/"/>
		<updated>2020-11-24T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/</id>
		<content type="html">&lt;p&gt;This is the fourth part in my review and reading notes on the Practical Object Oriented Programming book (www.poodr.com) by Sandi Metz.&lt;/p&gt;
&lt;p&gt;Okay now it&#39;s getting interesting: OOD is about &lt;em&gt;messages&lt;/em&gt; more than &lt;em&gt;classes&lt;/em&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;What&lt;/em&gt; objects know = Their responsibilities&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Who&lt;/em&gt; objects know = Their dependencies&lt;/li&gt;
&lt;li&gt;How classes &lt;em&gt;talk&lt;/em&gt; to each other = The messages and their &lt;em&gt;interfaces&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;understanding-interfaces&quot; tabindex=&quot;-1&quot;&gt;Understanding Interfaces &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Nerd time: Think of classes as nodes in a graph, and of messages as directed edges. Good design has a &lt;em&gt;sparse&lt;/em&gt; graph: Any given node should have a relatively low number of outgoing edges, or at least there should be small clusters of higher connectivity, with the clusters in turn being loosely connected to each other.&lt;/p&gt;
&lt;p&gt;More nerd time: If &amp;quot;everybody talks to everybody else&amp;quot;, then with &lt;em&gt;N&lt;/em&gt; classes you will have
O(N^2) edges. That is, the number of communication paths grows quadratically with the number of classes. That quickly becomes overwhelmingly complex.&lt;/p&gt;
&lt;p&gt;Hyper-connected objects are difficult to reuse and change.&lt;/p&gt;
&lt;p&gt;Instead, low-connected components allow easy reuse and low-consequence change.&lt;/p&gt;
&lt;p&gt;High-density message graph is &lt;em&gt;not&lt;/em&gt; necessarily the result of failed dependency injection or single responsibility! You can easily design an application that follows those principles while still ending up with a dense message graph.&lt;/p&gt;
&lt;p&gt;Problems aren&#39;t with what the class &lt;em&gt;does&lt;/em&gt; but with what it &lt;em&gt;reveals&lt;/em&gt;. To arrive at a low-density message graph, you need to &lt;em&gt;constrain&lt;/em&gt; which messages can pass between objects.&lt;/p&gt;
&lt;p&gt;In some programming langauges, a class can explicitly declare its methods to be either public or private. In Python, though, all class attributes and methods are public. There is, however, a &lt;em&gt;convention&lt;/em&gt; which states that, as a programmer, you should treat attributes and messages that start with an underscore &lt;em&gt;as if&lt;/em&gt; they were private. That is: Don&#39;t depend on their behavior, don&#39;t depend even on their existence. With the underscore prefix, you signal to other programmers and to yourself that this message is not part of the class&#39;s public interface.&lt;/p&gt;
&lt;p&gt;In this chapter, &lt;em&gt;interface&lt;/em&gt; refers to the methods &lt;em&gt;within&lt;/em&gt; a class, as opposed to the more abstract concept of interface we&#39;ll talk about in the next chapter.&lt;/p&gt;
&lt;h1 id=&quot;defining-interfaces&quot; tabindex=&quot;-1&quot;&gt;Defining Interfaces &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;The author gives a great example of an interface that hides complex implementation details with the restaurant kitchen analogy. Another example I can think of: The devices we use every day also have devices that hide the implementation details. I don&#39;t need to know anything at all about electronics to use a TV. I don&#39;t need to know anything about how an internal combustion engine &lt;em&gt;actually&lt;/em&gt; works to drive a car. The interface provides me with means of telling the device &lt;em&gt;what&lt;/em&gt; I want from it (go faster, slow down, go left, go right) without me having to bother at all &lt;em&gt;how&lt;/em&gt; this behavior is achieved.&lt;/p&gt;
&lt;h2 id=&quot;public-interfaces&quot; tabindex=&quot;-1&quot;&gt;Public Interfaces &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Just some bullet points here.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Public methods = Face of your class&lt;/li&gt;
&lt;li&gt;Tell you what it&#39;s primary responsibility is&lt;/li&gt;
&lt;li&gt;Are &lt;em&gt;expected&lt;/em&gt; to be invoked by others&lt;/li&gt;
&lt;li&gt;Will &lt;em&gt;not&lt;/em&gt; change on a whim.&lt;/li&gt;
&lt;li&gt;Are (more or less) safe for others to depend on.&lt;/li&gt;
&lt;li&gt;Are thoroughly documented in tests.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;private-interfaces&quot; tabindex=&quot;-1&quot;&gt;Private Interfaces &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;All other methods = private interface&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Handle implementation details&lt;/li&gt;
&lt;li&gt;Are &lt;em&gt;not&lt;/em&gt; expected to be sent by other objects&lt;/li&gt;
&lt;li&gt;Chan change for any reason whatsoever&lt;/li&gt;
&lt;li&gt;Are &lt;em&gt;unsafe&lt;/em&gt; for others to depend on&lt;/li&gt;
&lt;li&gt;May not even be referenced in tests&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;responsibilities-dependencies-and-interfaces&quot; tabindex=&quot;-1&quot;&gt;Responsibilities, Dependencies, and Interfaces &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;If a class has a single &lt;em&gt;purpose&lt;/em&gt;, then things it does (its specific &lt;em&gt;responsibilities&lt;/em&gt;) are what allow it to fulfill that purpose.&lt;/li&gt;
&lt;li&gt;Public methods = description of its responsibilities.&lt;/li&gt;
&lt;li&gt;Public interface is a &lt;em&gt;contract&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Example of Stack: &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;pop&lt;/code&gt; is pretty much all you need. Internal details should be hidden.&lt;/li&gt;
&lt;li&gt;Remember: Depend on things that are more stable than you. Applies to classes (previous chapter) but also applies to methods. What&#39;s that mean? Don&#39;t &lt;em&gt;depend&lt;/em&gt; on private methods.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;finding-the-public-interface&quot; tabindex=&quot;-1&quot;&gt;Finding the Public Interface &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;It&#39;s an art&lt;/li&gt;
&lt;li&gt;No hard rules&lt;/li&gt;
&lt;li&gt;Recall the design goal: Maximum future flexibility with not too much work right now.&lt;/li&gt;
&lt;li&gt;Now some rules of thumb and a new tool: Sequence Diagrams.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;example&quot; tabindex=&quot;-1&quot;&gt;Example &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Author introduces an example &lt;em&gt;domain&lt;/em&gt;. I won&#39;t repeat that here.&lt;/p&gt;
&lt;h2 id=&quot;constructing-an-intention&quot; tabindex=&quot;-1&quot;&gt;Constructing an Intention &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here author has a bit of a discussion on &amp;quot;test first&amp;quot; programming, also called TDD for Test-Driven Design. The idea of that design technique is to write unit tests first, and let the tests guide you into what code to write for your program. However, as the author argues, that often does not end well for &lt;em&gt;novices&lt;/em&gt; to design, because if you don&#39;t know &lt;em&gt;which&lt;/em&gt; tests to write, and &lt;em&gt;how&lt;/em&gt; to write them, they cannot possibly guide you to a good design.&lt;/p&gt;
&lt;p&gt;Once you have acquired good design experience and intuition, you will know which tests to write to hone in on the specific design that will work well for your given situation.&lt;/p&gt;
&lt;p&gt;The authors calls this &amp;quot;having an &lt;em&gt;intention&lt;/em&gt; about the application&amp;quot;: To write test-first in a good way, you need to know: &amp;quot;I want my object to have this method, which should exhibit this behavior&amp;quot;.&lt;/p&gt;
&lt;p&gt;Going a step further: Before writing these tests you also need an idea about &lt;em&gt;which&lt;/em&gt; objects you will have. Novices focus overly on the &lt;em&gt;domain objects&lt;/em&gt;. The concrete, tangible things. The &lt;em&gt;nouns&lt;/em&gt; of the domain, if you will. What is more important, though, is what &lt;em&gt;message&lt;/em&gt; you intend to pass between these objects!&lt;/p&gt;
&lt;p&gt;So before you do anything, figure out what objects &lt;em&gt;and&lt;/em&gt; what messages you&#39;ll be dealing with.&lt;/p&gt;
&lt;h2 id=&quot;sequence-diagrams&quot; tabindex=&quot;-1&quot;&gt;Sequence Diagrams &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;How do we sketch out what messages we&#39;re dealing with? Sequence diagrams! Subset of UML (Unified Markup Language) diagrams. I won&#39;t repeat the chapter content and diagrams here, just pointing out that there&#39;s a free Sequence Diagram Tool here:
https://sequencediagram.org/&lt;/p&gt;
&lt;p&gt;Why are these diagrams so great? Because they force you to be clear about which messages you are going to send. That, in turn, allows you to ponder whether you&#39;re sending them from and to the right objects. And since you&#39;re only supposed to send messages that are in the public interface of classes, the diagram helps you figure out what the public interface should be.&lt;/p&gt;
&lt;p&gt;Let&#39;s emphasize this: Instead of deciding on a class, and &lt;em&gt;then&lt;/em&gt; figuring out what its responsibilities are, you decide on a &lt;em&gt;message&lt;/em&gt; you want to send, and then figure out who should send it, and where to.&lt;/p&gt;
&lt;p&gt;I&#39;ll quote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This transition from class-based design to message-based design is a turning point in your design career. The message-based perspective yields more flexible applications than does the class-based perspective. Changing the fundamental design question from I know I need this class, what should it do? to I need to send this message, who should respond to it? is the first step in that direction.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;You dont send messages because you have objects, you have objects because you send messages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;When focusing too much on classes, we risk that our messages aren&#39;t sent to the right place.&lt;/p&gt;
&lt;p&gt;The book then goes through a concrete example involving a bicylce trip agency and how a sequence diagram can help identify issues with the objects and messages.&lt;/p&gt;
&lt;h2 id=&quot;asking-for-what-instead-of-telling-how&quot; tabindex=&quot;-1&quot;&gt;Asking For &amp;quot;What&amp;quot; Instead Of Telling &amp;quot;How&amp;quot; &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;One such issue is about messages that are too explicit in what exact behavior they want to see.&lt;/p&gt;
&lt;p&gt;You want to be sending messages that tell the receiver what sort of result you want from them. You want to avoid sending messages that tell the receiver how to behave.&lt;/p&gt;
&lt;p&gt;In the restaurant example, you tell the waiter which dish you would like. You don&#39;t tell the waiter &amp;quot;Please write this dish and my table number onto this note and then go put that note onto the stack of kitchen orders and then wait for the chef to make the order and then bring it to me&amp;quot;.&lt;/p&gt;
&lt;p&gt;The book example explains this via the bicycle mechanic class. In a first version, the trip class explicitly states all the different actions that a mechanic should take to prepare a bike. This is a case of telling &amp;quot;how&amp;quot;.&lt;/p&gt;
&lt;p&gt;A good test to see if your design falls into this trap is to imagine your classes again as people, where a message is like an order or request. Now imagine the sequence diagram as a conversation between the people. If one class feels like it&#39;s a tyrannical micro-manager toward another, you need to rethink your design!&lt;/p&gt;
&lt;p&gt;If your messages instead focus on the high-level tasks and results you want to see, the object that sends the message needs to know much less, and the object that performs the task can have a much smaller public interface.&lt;/p&gt;
&lt;h2 id=&quot;seeking-context-independence&quot; tabindex=&quot;-1&quot;&gt;Seeking Context Independence &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;An object&#39;s &lt;em&gt;context&lt;/em&gt; is formed by all the things it expects to be in place and available to perform its job. Typically, this context involves what sort of messages your object expects to be able to send to other objects, with some assumptions about the behavior.&lt;/p&gt;
&lt;p&gt;Look again at the toy example from my previous writeup, with dependency injection:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper
		
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	
	&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the &lt;em&gt;context&lt;/em&gt; of class &lt;code&gt;A&lt;/code&gt; is &amp;quot;an object that understands the &lt;code&gt;process(arg1, arg2)&lt;/code&gt; message&amp;quot;.&lt;/p&gt;
&lt;p&gt;Obviously, the bigger an object&#39;s context, the harder it is to use, re-use, and test the class, because you first need to &lt;em&gt;create&lt;/em&gt; the correct context. This suggests that good design seeks to write classes that require only a small context. The &lt;em&gt;best case scenario&lt;/em&gt; of course is a class that is context-independent.&lt;/p&gt;
&lt;p&gt;To be context-independent means being able to cooperate with other objects without knowing &lt;em&gt;who they are&lt;/em&gt; and &lt;em&gt;what they do&lt;/em&gt;. Using dependency injection takes care of the &lt;em&gt;who&lt;/em&gt; part. Rethinking the sequence of messages, and working toward simplifying the messages, takes care of the &lt;em&gt;what they do&lt;/em&gt; part.&lt;/p&gt;
&lt;p&gt;I like the author&#39;s example here with the Trip and the Mechanic. The key technique the example in this subsection introduces is: You can simplify (and thus potentially unify) the message you send to your collaborator by &lt;em&gt;not&lt;/em&gt; passing in lots of arguments, but rather having a public interface that lets your collaborator ask you for those arguments themselves.&lt;/p&gt;
&lt;p&gt;Maybe we can use the restaurant example again:
&lt;img src=&quot;https://cadolphs.github.io/images/poodr_4/burger_1.png&quot; alt=&quot;Sequence Diagram for ordering a burger explicitly&quot;&gt;&lt;/p&gt;
&lt;p&gt;Here we see a Customer ordering a burger, which needs a bit of extra info about the side dish. Sending messages like this requires having a method for each of the different things you could order in different ways. It means &lt;code&gt;Customer&lt;/code&gt; expects in its context an object &lt;code&gt;Waiter&lt;/code&gt; that understands all sorts of messages.&lt;/p&gt;
&lt;p&gt;If we have our objects collaborate more, however, we can have a simpler context:
&lt;img src=&quot;https://cadolphs.github.io/images/poodr_4/burger_2.png&quot; alt=&quot;Sequence Diagram for ordering a burger with less context&quot;&gt;&lt;/p&gt;
&lt;p&gt;and we&#39;d imagine that it&#39;s the customer&#39;s interface&#39;s job to provide methods to inquire about certain preferences, like doneness of a steak, whether Pepsi is okay, and if there&#39;s allergies.&lt;/p&gt;
&lt;h2 id=&quot;trusting-other-objects&quot; tabindex=&quot;-1&quot;&gt;Trusting Other Objects &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the real world, you are only comfortable asking for the what without specifying the how if you have trust that your counterpart is capable of fulfilling that request. When writing your own classes and objects, you should always trust an object that it is capable of fulfilling its responsibility!&lt;/p&gt;
&lt;p&gt;As the author argues, the various sequence diagrams of the section show how a programmer&#39;s understanding and use of objects improves over time:&lt;/p&gt;
&lt;p&gt;The first stab is essentially &lt;em&gt;procedural&lt;/em&gt;. In a purely procedural program, you have some &lt;code&gt;main()&lt;/code&gt; routine that, in sequence, calls the various procedures (functions) it needs to get its job done. Just because you put your &lt;code&gt;main&lt;/code&gt; into one class and all the procedures it calls into another class does not make your code truly object oriented!&lt;/p&gt;
&lt;p&gt;In the next version, the detailed knowledge of which functions to call in what order to accomplish a given task has been moved to the correct class. The &amp;quot;main&amp;quot; class asks the helper class to achieve a specific result, but does not itself specify how that is achieved.&lt;/p&gt;
&lt;p&gt;In the final version, the &lt;em&gt;context&lt;/em&gt; of the main class is reduced further. The difference in the author&#39;s example between &lt;code&gt;prepare_bicycle(bike)&lt;/code&gt; and &lt;code&gt;prepare_trip()&lt;/code&gt; is subtle but profound. Preparing a trip, rather than preparing a bike, is a more &lt;em&gt;general&lt;/em&gt; concept. As such, it is more stable and more reusable. We &lt;em&gt;trust&lt;/em&gt; that the Mechanic class itself knows that, in order to prepare a trip, it must prepare a bike.&lt;/p&gt;
&lt;p&gt;The impact of this subtle shift becomes more visible when we imagine that a trip has many different things that need to be prepared other than getting bikes ready. Code quickly becomes messy if we have to send specific &amp;quot;you prepare this, and you prepare that&amp;quot; messages to all the different classes that help us get ready for a trip. Much better if we can just send each class the same &lt;code&gt;prepare_trip&lt;/code&gt; message and the classes themselves know what to do.&lt;/p&gt;
&lt;h2 id=&quot;using-messages-to-discover-objects&quot; tabindex=&quot;-1&quot;&gt;Using Messages to Discover Objects &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The sequence diagrams should be understood as lightweight, temporary, throw-away tools that help us discover which objects our application needs. We do this by examining what types of messages are reasonable to &lt;em&gt;send&lt;/em&gt; and then carefully scrutizing what sort of object should be responsible for &lt;em&gt;receiving&lt;/em&gt; that message.&lt;/p&gt;
&lt;p&gt;This view of putting messages first is incredibly helpful. Focusing too much on the existing objects makes it tempting to just shove messages into whatever objects are already there. Focusing instead of the messages we want to send allows us to create the right class, with the right single responsibility, for handling that message.&lt;/p&gt;
&lt;h1 id=&quot;writing-code-that-puts-its-best-interface-forward&quot; tabindex=&quot;-1&quot;&gt;Writing Code That Puts Its Best Interface Forward &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;In this section, the author shares useful rules of thumb for creating good public interfaces. In any way, you should always &lt;em&gt;think&lt;/em&gt; carefully about your interfaces, as they control more than anything else how your codebase will evolve.&lt;/p&gt;
&lt;h2 id=&quot;create-explicit-interfaces&quot; tabindex=&quot;-1&quot;&gt;Create Explicit Interfaces &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Python has no explicit concept of private versus public methods, but convention says that methods prefixed with &lt;code&gt;_&lt;/code&gt; should be &lt;em&gt;considered&lt;/em&gt; private and &lt;em&gt;not&lt;/em&gt; be depended upon.&lt;/p&gt;
&lt;p&gt;The public methods are those that you want other classes to call and depend on. Therefore, they should be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Explicitly identified as such. In Python, that just means &lt;em&gt;not&lt;/em&gt; having the &lt;code&gt;_&lt;/code&gt; prefix.&lt;/li&gt;
&lt;li&gt;Be more about &lt;em&gt;what&lt;/em&gt; than &lt;em&gt;how&lt;/em&gt;. Remember to trust your objects.&lt;/li&gt;
&lt;li&gt;Have descriptive names that won&#39;t be subject to change, as much as possible.&lt;/li&gt;
&lt;li&gt;Prefer keyword arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;honor-the-public-interfaces-of-others&quot; tabindex=&quot;-1&quot;&gt;Honor the Public Interfaces of Others &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Basically, avoid as much as possible depending on private methods of other classes! In some languages this isn&#39;t an &lt;em&gt;option&lt;/em&gt;, but Python of course does not prevent you from calling a method just because it was prefixed with the underscore.&lt;/p&gt;
&lt;p&gt;Still, all sorts of alarm bells should be going off in your head if you ever feel tempted to invoke such a &amp;quot;private&amp;quot; method. The person who wrote that class&#39;s interface decided to mark that method as private for a reason: It is considered an internal detail of the class, subject to change at a whim, with no promises made to preserve the private method.&lt;/p&gt;
&lt;p&gt;Chances are, when you find yourself calling a private method, that you&#39;re telling a class &lt;em&gt;how&lt;/em&gt; to do something rather than asking it for &lt;em&gt;what&lt;/em&gt; you want done. Rethink your design!&lt;/p&gt;
&lt;p&gt;If you are convinced that it absolutely cannot be avoided to call a private method, isolate this dangerous dependency from the rest of your code base so that the private method is referenced from only one place, instead of all over your application.&lt;/p&gt;
&lt;h2 id=&quot;minimize-context&quot; tabindex=&quot;-1&quot;&gt;Minimize Context &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As discussed above, a class&#39;s context is the set of other classes and things that are required to be in place before a class can actually do its job. Smaller is better. In terms of a public interface, then, this means providing public methods that allows senders to get what they want without having to spell out the steps needed to get there.&lt;/p&gt;
&lt;p&gt;Basically, if you don&#39;t want your class to be micro-managed by other classes, it is your job to provide methods that represent high-level results instead of low-level actions.&lt;/p&gt;
&lt;p&gt;If you have to use someone else&#39;s class with a poor public interface, you should also consider putting in the work to wrap the bad interface into a class or method that provides a better interface.&lt;/p&gt;
&lt;h1 id=&quot;the-law-of-demeter&quot; tabindex=&quot;-1&quot;&gt;The Law of Demeter &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;I have talked about this before on this site so I won&#39;t go into too much detail again. I like the author&#39;s nuanced approach to the law so I will comment on that a bit.&lt;/p&gt;
&lt;p&gt;The Law of Demeter, in short, says to avoid &lt;em&gt;train wrecks&lt;/em&gt; of long chains of methods. But there are subtleties to conisder.&lt;/p&gt;
&lt;h2 id=&quot;consequences-of-violations&quot; tabindex=&quot;-1&quot;&gt;Consequences of Violations &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Whenever someone states that there&#39;s a law you shouldn&#39;t violate, a natural question to arise is: &amp;quot;Or else?&amp;quot;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A long message chain increases coupling between distant objects. Ask yourself if that coupling is appropriate and unavoidable.&lt;/li&gt;
&lt;li&gt;Depending on a long message chain increases an object&#39;s &lt;em&gt;context&lt;/em&gt;: More things need to be correctly in place, making reuse and testing cumborsome!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There&#39;s a few different &lt;em&gt;types&lt;/em&gt; of message chains, and the law&#39;s importance depends on that type.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You could be retrieving a &lt;em&gt;stable attribute&lt;/em&gt; via some intermediate objects. In this case, balance the cost of removing the violation against the likelihood of this chain breaking.&lt;/li&gt;
&lt;li&gt;You could be invoking distant behavior. This is most likely a situation where you are telling &lt;em&gt;how&lt;/em&gt; rather than &lt;em&gt;what&lt;/em&gt;, and hints at a deficient public interface. More on this later.&lt;/li&gt;
&lt;li&gt;You could be chaining together methods that have the same return type; often called a &lt;em&gt;fluid interface&lt;/em&gt;. In this case, all is fine, as the Law of Demeter only concerns method chains with different objects along the chain.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;avoiding-violations&quot; tabindex=&quot;-1&quot;&gt;Avoiding Violations &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Sometimes when the Law of Demeter is discussed, &lt;em&gt;delegation&lt;/em&gt; is sold as the way to avoid the violation:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;get_something&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; some_object
	
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_something&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
		
&lt;span class=&quot;token comment&quot;&gt;# Some code:&lt;/span&gt;
A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# Law of Demeter violation&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The idea of delegation is that we move the message chain into the classes:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;get_something&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; some_object
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_something&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;# unchanged&lt;/span&gt;
	
&lt;span class=&quot;token comment&quot;&gt;# Some code:&lt;/span&gt;
A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;# Hah! No Law of Demeter violation!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At times, this can be the appropriate course of action, but pay attention! You might still be violating the law &lt;em&gt;in spirit&lt;/em&gt; if not in letter. Thinking back to our discussion about messages and their appropriate senders and receivers, does it &lt;em&gt;make sense&lt;/em&gt; for &lt;code&gt;A&lt;/code&gt; to receive this particular &lt;code&gt;do_something&lt;/code&gt; message?&lt;/p&gt;
&lt;h2 id=&quot;listening-to-demeter&quot; tabindex=&quot;-1&quot;&gt;Listening to Demeter &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-24-poodr-chapter4/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;What the Law of Demeter &lt;em&gt;really&lt;/em&gt; wants to tell us is that we are either missing objects, or methods, that would allow our objects to communicate in a more useful way! According to the author, these &lt;em&gt;train wrecks&lt;/em&gt; happen if we focus too much on the objects we already have: This leads us to chain method calls together to assemble some desired behavior. If instead we focus on the &lt;em&gt;messages&lt;/em&gt; that we &lt;em&gt;should&lt;/em&gt; be sending, we will discover which objects need to receive them:&lt;/p&gt;
&lt;p&gt;In the preceding examples, we discussed why it&#39;s bad if one class tells another class in too much detail exactly what to do. Even worse, then, is if we have one class that tells another class to tell another class exactly what to do.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 3</title>
		<link href="https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/"/>
		<updated>2020-11-18T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/</id>
		<content type="html">&lt;p&gt;This is the third post in my book review / book notes series about &amp;quot;Practical Object Oriented Design&amp;quot; by Sandi Metz. (https://www.poodr.com/)&lt;/p&gt;
&lt;p&gt;The previous chapter was focused on a single class, and how each class should have one single responsibility. If you design your classes in this way, then obviously any complex behavior must be the result of classes &lt;em&gt;collaborating&lt;/em&gt;. This need for collaboration introduces &lt;em&gt;dependencies&lt;/em&gt; between the classes, and the job of good design is to manage these dependencies in the best possible way.&lt;/p&gt;
&lt;p&gt;Basically, if you ask a class to do something, there&#39;s three ways this can happen:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The expected behavior is implemented by the class itself. (See last chapter)&lt;/li&gt;
&lt;li&gt;The class &lt;em&gt;inherits&lt;/em&gt; the behavior from another class. (Discussed in a subsequent chapter)&lt;/li&gt;
&lt;li&gt;The class &lt;em&gt;delegates&lt;/em&gt; the behavior to another class. This is what we talk about in this chapter&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;understanding-dependencies&quot; tabindex=&quot;-1&quot;&gt;Understanding Dependencies &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;As mentioned, collaboration introduces dependencies. We say that A depends on B if A might have to change when B changes. Consider this abstract example:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		some_intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let us list all the ways in which class A depends on class B. Class A &lt;strong&gt;knows&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The name of the class B, and how to create a new instance of it.&lt;/li&gt;
&lt;li&gt;The name of the method it needs to call (i.e. the name of the message to send to class B).&lt;/li&gt;
&lt;li&gt;The arguments required by that message.&lt;/li&gt;
&lt;li&gt;The order of those arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some of these dependencies are inevitable. But many are not! And you&#39;d be surprised!&lt;/p&gt;
&lt;p&gt;Good Design: Manage dependencies so that each class has fewest possible. &lt;em&gt;Just&lt;/em&gt; enough to do its job and nothing more.&lt;/p&gt;
&lt;h2 id=&quot;coupling-between-objects-cbo&quot; tabindex=&quot;-1&quot;&gt;Coupling Between Objects (CBO) &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A dependency between classes A and B &lt;em&gt;couples&lt;/em&gt; them to each other. The more tightly coupled, the more it&#39;s basically one entity. That limits reuse, and makes change harder, because now it&#39;s spread over more than just one class. In the example above, we cannot reuse &lt;code&gt;A&lt;/code&gt; without also bringing &lt;code&gt;B&lt;/code&gt; along for the ride.&lt;/p&gt;
&lt;p&gt;Sometimes, this is not a big deal. For example, a given class might bring along with it a number of custom-defined exception classes, like &lt;code&gt;CouldNotDoMyJobException&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;More often than not though, strong coupling is &lt;em&gt;not&lt;/em&gt; inevitable. Below we will see some examples and techniques for addressing this.&lt;/p&gt;
&lt;h2 id=&quot;other-dependencies&quot; tabindex=&quot;-1&quot;&gt;Other Dependencies &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A quick aside that other chapters will deal with certain other types of dependencies. Just a quick overview:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Law of Demeter: Imagine if one object knows another who knows another who knows something. This dependency on a complete &lt;em&gt;chain&lt;/em&gt; of objects knowing each other is fragile and best avoided.&lt;/li&gt;
&lt;li&gt;Test-to-code coupling! Another type of dependency. Learn about writing good, cost-effective tests that aren&#39;t fragile! (Chapter 9)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;writing-loosely-coupled-code&quot; tabindex=&quot;-1&quot;&gt;Writing Loosely Coupled Code &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Back to the four original examples of couplings.&lt;/p&gt;
&lt;p&gt;The author describes dependencies as &lt;em&gt;little dots of glue&lt;/em&gt; where the various classes neatly fit together. But if you have too much glue, everything devolves into one big lumpy mess.&lt;/p&gt;
&lt;p&gt;We&#39;ll look now into specific techniques that address the four dependencies we mentioned above.&lt;/p&gt;
&lt;h2 id=&quot;inject-dependencies&quot; tabindex=&quot;-1&quot;&gt;Inject Dependencies &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;So in our toy exmaple, class A knows the name of class B. That is a dependency. If we change the name of class B, we have to update it in class A.&lt;/p&gt;
&lt;p&gt;Now what&#39;s the big deal with that? There&#39;s simple search-and-replace functionality, and there&#39;s modern IDEs with refactoring support. So really the mere name itself isn&#39;t the problem here.&lt;/p&gt;
&lt;p&gt;The real problem is that we are hard-coding the creation of instances of class B. Class A has some responsibility (&lt;code&gt;do_your_job&lt;/code&gt;) that it cannot completely fulfill on its own. It needs to collaborate with another class, and in the current code version, it decides to &lt;em&gt;only&lt;/em&gt; collaborate with instances of class B. The author calls this an &lt;em&gt;unjustified attachment to type&lt;/em&gt;. Ultimately, we don&#39;t care about the name of the class, or even its exact type. We care about sending it the &lt;code&gt;process(arg1, arg2)&lt;/code&gt; message!&lt;/p&gt;
&lt;p&gt;The simplest way to deal with this problem has the fancy name of &lt;em&gt;dependency injection&lt;/em&gt;:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper
		
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		some_intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we decide that it&#39;s not the job of class A to know how to &lt;em&gt;make&lt;/em&gt; a &lt;code&gt;job_helper&lt;/code&gt;. It needs one to collaborate with, so we pass it in. The example above &lt;em&gt;injects&lt;/em&gt; the &lt;code&gt;job_helper&lt;/code&gt; dependency in the class&#39;s &lt;code&gt;__init__&lt;/code&gt;, but we could also consider passing it in at the method level, as in &lt;code&gt;do_your_job(self, arg1, arg2, job_helper)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Of course &lt;em&gt;somewhere&lt;/em&gt; in our program we will have to create an instance of a class that responds to the &lt;code&gt;process&lt;/code&gt; message, which might very well be an instance of class B. But we have decided that knowing what class to instantiate, and how, is not the job of class A.&lt;/p&gt;
&lt;p&gt;Writing your code this way also makes it easier to write unit tests for your code! In the previous version, testing class A without also testing class B would be a bit tricky. At least in Python we can use &amp;quot;monkey patching&amp;quot; to mock out class B. But it is much cleaner and easier if we can just pass in either a mock or a dummy version of a &lt;code&gt;job_helper&lt;/code&gt; directly. More on testing will come in a later chapter.&lt;/p&gt;
&lt;p&gt;Maybe at this point I will mention one additional technique, or pattern: Sometimes it is not enough to inject an instance of a class to collaborate with. Imagine our class A needed to be able to create new instances of the &lt;code&gt;job_helper&lt;/code&gt;. How can it possibly do that without knowing the name of the class it needs to create? The answer is: Through a &lt;em&gt;factory&lt;/em&gt;. Instead of passing in a &lt;code&gt;job_helper&lt;/code&gt; into the &lt;code&gt;__init__&lt;/code&gt;, we would pass in a &lt;code&gt;job_helper_factory&lt;/code&gt;. Then, whenever class A would need to get its hands on a new instance of a job helper, it could call something like &lt;code&gt;job_helper_factory.make_new_job_helper()&lt;/code&gt;. The knowledge of what concrete class to instantiate is completely contained within that factory class.&lt;/p&gt;
&lt;p&gt;To recap: Realize that creating instances of a class can be seen as a &lt;em&gt;responsibility&lt;/em&gt; that may or may not belong into your class. If it doesn&#39;t, use dependency injection to provide your class with its dependencies.&lt;/p&gt;
&lt;h2 id=&quot;isolate-dependencies&quot; tabindex=&quot;-1&quot;&gt;Isolate Dependencies &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here the author briefly addresses what you could do if you don&#39;t have full control over the codebase &lt;em&gt;or&lt;/em&gt; just not enough time to complete get rid of all the unnecessary dependencies right now.&lt;/p&gt;
&lt;p&gt;If that&#39;s the case, you should at least &lt;em&gt;isolate&lt;/em&gt; them:&lt;/p&gt;
&lt;h3 id=&quot;isolate-instance-creation&quot; tabindex=&quot;-1&quot;&gt;Isolate Instance Creation &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In our &lt;code&gt;class A&lt;/code&gt; example above, let&#39;s say we cannot move creation of class &lt;code&gt;B&lt;/code&gt; to some outside part. Then at lest we should &lt;em&gt;isolate&lt;/em&gt; this creation, maybe like so:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;get_new_job_helper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get_new_job_helper&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		some_intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Assuming that in a more complex example, creations of &lt;code&gt;B&lt;/code&gt; might be sprinkled all throughout class A&#39;s methods, moving that creation to exactly one method isolates this dependency and makes it explicit: Reading the code of class A, we immediately see that it explicitly depends on class B. The dependency is not hidden deep in the belly of some method. This helps us maintain the code, and also is a great reminder to us to consider refactoring the code further, to get rid of that dependency.&lt;/p&gt;
&lt;h3 id=&quot;isolate-vulnerable-external-messages&quot; tabindex=&quot;-1&quot;&gt;Isolate Vulnerable External Messages &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Imagine in our simple example that &lt;code&gt;job_helper.process&lt;/code&gt; was called in a lot of places, or called deep inside an internal method. &lt;em&gt;If&lt;/em&gt;, in the current phase of our design and coding process, we reasonably expect that this &lt;code&gt;process&lt;/code&gt; message might change, it is a good idea to &lt;em&gt;isolate&lt;/em&gt; this message in a separate method:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;get_new_job_helper&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get_new_job_helper&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		some_intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If that whole job-helper and process code happened in multiple places of our code, extracting it into its own method is a good idea anyway, due to the &amp;quot;Don&#39;t Repeat Yourself&amp;quot; principle. But even if it only happens in exactly one place, it might still be a good idea to extract it, to move the interesting bits out from the depths of an internal method, so that the dependency becomes explicit and obvious.&lt;/p&gt;
&lt;h2 id=&quot;remove-argument-order-dependencies&quot; tabindex=&quot;-1&quot;&gt;Remove Argument-Order Dependencies &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Briefly, knowing in which &lt;em&gt;order&lt;/em&gt; to pass in arguments is &lt;em&gt;also&lt;/em&gt; a dependency, and one that can make it hard to later change a method&#39;s signature by adding new arguments. Especially early on in design, your methods&#39; signatures will probably change a lot, so it makes sense to try and not depend on this order.&lt;/p&gt;
&lt;p&gt;Luckily, this is very eason in Python by using keyword arguments. You don&#39;t even have to change how to define the method itself, just how you call it.&lt;/p&gt;
&lt;p&gt;When using keyword arguments, you trade one dependency on another: Instead of depending on the order of arguments, you now depend on the &lt;em&gt;names&lt;/em&gt; of the arguments. So we don&#39;t really reduce the number of dependencies when using keyword arguments. Is it still worth it? Yes! Not all dependencies are equal. Some are better than others. Argument &lt;em&gt;names&lt;/em&gt; are more &lt;em&gt;stable&lt;/em&gt; and more &lt;em&gt;explicit&lt;/em&gt; than argument order. If you have to depend on &lt;em&gt;something&lt;/em&gt;, try to depend on something that&#39;s less likely to change and try to depend on it in a way that&#39;s explicit.&lt;/p&gt;
&lt;h3 id=&quot;kwargs-in-python&quot; tabindex=&quot;-1&quot;&gt;kwargs in Python &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;One extra thought, a short excursion, at this point: Python allows a method to accept &lt;em&gt;any&lt;/em&gt; keyword argument via the &lt;code&gt;**kwargs&lt;/code&gt; syntax: &lt;code&gt;def function(an_argument, **kwargs)&lt;/code&gt; will store any keyword arguments
passed when calling &lt;code&gt;function&lt;/code&gt; in the dictionary &lt;code&gt;kwargs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I admit that I am &lt;em&gt;not&lt;/em&gt; a big fan of this, because it &lt;em&gt;obscures&lt;/em&gt; what arguments we are expecting. A caller would have to read the docstring (which might be out of date!) or, worse, dive into the body of the function to discern which keyword arguments there are.&lt;/p&gt;
&lt;p&gt;Often you see this construct when one function takes a few keywords out of the dict (via &lt;code&gt;pop&lt;/code&gt;) and then passes the rest along to another function it calls. Almost always when I see this, there is a violation of the Single Responsibility Principle, or a mis-managed dependency. I believe that in the majority of cases, a better design can eliminate the need for using the catch-all &lt;code&gt;**kwargs&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One common use-case (and anti-pattern, really) for kwargs occurs in mismatched class hierarchies. We talk about inheritance later, but assuming that you are familiar with the basic concept, you sometimes see a class hierarchy where the various child classes, inheriting from the same base class, want slightly different signatures for their methods:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Base&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;pass&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ChildA&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Base&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt;kwargs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
		
&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;ChildB&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Base&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;**&lt;/span&gt;kwargs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;
		&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The justification here for using &lt;code&gt;kwargs&lt;/code&gt; is that, at least syntactically, you can call &lt;code&gt;some_function&lt;/code&gt; for each of these three classes with the same arguments. The problem is that, if you really require different signatures for the various classes, they shouldn&#39;t be related via inheritance in the first place! The whole idea behind inheritance and polymorphism is that someone sending the &lt;code&gt;some_function&lt;/code&gt; method does not, and &lt;em&gt;should not&lt;/em&gt;, need to know whether the recipient is &lt;code&gt;Base&lt;/code&gt;, &lt;code&gt;ChildA&lt;/code&gt;, or &lt;code&gt;ChildB&lt;/code&gt;. Code like the one above &lt;em&gt;begs&lt;/em&gt; for the anti-pattern of the type switch:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someclass&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ChildA&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	someclass&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_function&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; special_argument_for_child_a&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;isinstance&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;someclass&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; ChildB&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	someclass&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;some_function&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; special_argument_for_child_b&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Seriously reconsider your design at this point. Evaluate whether inheritance is what you want, and explore how you could rearrange the code such that the signatures of inherited methods remain the same.&lt;/p&gt;
&lt;h1 id=&quot;managing-dependency-direction&quot; tabindex=&quot;-1&quot;&gt;Managing Dependency Direction &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;In a lot of cases, and certainly in the example above, the dependency has a specific direction: Class A had a dependency on class B, but class B did &lt;em&gt;not&lt;/em&gt; have a dependency on class A. It is however often possible to rearrange your code and your general logic in such a way that, instead, B would depend on A.&lt;/p&gt;
&lt;p&gt;Let&#39;s recall the old version of the toy example a bit:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	job_helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; B&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	some_intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; job_helper&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_some_internal_calculations&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we decide to remove the responsibility of &amp;quot;doing the job&amp;quot; from class A to class B, we could have a result like this:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;help_with_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;more_processing&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;B&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;do_your_job&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		some_intermediate_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;process&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		helper &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; A&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;help_with_job&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_intermediate_result&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, class B has a dependency on class A, and A does not depend on B anymore.&lt;/p&gt;
&lt;p&gt;Note that now of course we&#39;d look into whether or not we should &lt;em&gt;inject&lt;/em&gt; the instance of class A instead of creating it right here inside of class B, but that is not the focus of this section.&lt;/p&gt;
&lt;p&gt;Rather, the &lt;em&gt;ability&lt;/em&gt; to change the direction of dependencies raises the question: Which direction is the right one? Does it matter?&lt;/p&gt;
&lt;h3 id=&quot;choosing-dependency-direction&quot; tabindex=&quot;-1&quot;&gt;Choosing Dependency Direction &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The author says it best: You should depend on things that change less often than you do!&lt;/p&gt;
&lt;p&gt;This sounds simple, but it can have a profound impact on how you think about your code.&lt;/p&gt;
&lt;p&gt;Here, the author lists &amp;quot;three simple truths about code&amp;quot;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some classes more likely to change than others&lt;/li&gt;
&lt;li&gt;Concrete classes are more likely to change than abstract ones&lt;/li&gt;
&lt;li&gt;Changing a class that has many dependents will result in widespread consequences&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first point should be self-evident. The classes at the edge of our current development will change a lot. Classes at the core of a standard library will change rarely. In between is a wide spectrum. The well-understood core of our own application might be relatively stable but still change more often than the standard library.&lt;/p&gt;
&lt;p&gt;The second point might be more subtle. An abstract class is one that either only defines an interface without implementing it, or a class that fulfills a more abstract responsibility. Maybe it is a class that, concretely, facilitates messages between other, more concrete classes.&lt;/p&gt;
&lt;p&gt;The third point should be clear as well: All else being equal, changing a class on which a lot of other classes depends will always be messier than changing a class on which few other classes depend.&lt;/p&gt;
&lt;h3 id=&quot;recognizing-concretions-and-abstractions&quot; tabindex=&quot;-1&quot;&gt;Recognizing Concretions and Abstractions &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In this section we get a nice discussion of &amp;quot;concrete&amp;quot; versus &amp;quot;abstract&amp;quot;. We have already used this concept: When we used dependency injection in our very first example in this chapter, we removed the dependency on something &lt;em&gt;concrete&lt;/em&gt; (class B and how to create it) to something
more &lt;em&gt;abstract&lt;/em&gt;: The idea that there&#39;s certain objects, whatever they are and wherever they come from, that you can send the &lt;code&gt;process&lt;/code&gt; message.&lt;/p&gt;
&lt;p&gt;In languages with strict typing (Java, C++/C#), we would have to explicitly define an
&lt;em&gt;interface&lt;/em&gt;: An abstract class that expresses the abstract concept of understanding the &lt;code&gt;process&lt;/code&gt; message:&lt;/p&gt;
&lt;pre class=&quot;language-java&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;IJobHelper&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SomeReturnType&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;SomeType&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SomeOtherType&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then make it clear that our class A now expects a &lt;code&gt;job_helper&lt;/code&gt; passed into its constructor, with the type &lt;code&gt;IJobHelper&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In Python (and other dynamically typed languages such as Ruby) we do not have to explicitly declare an interface. Any object that happens to respond to the &lt;code&gt;process&lt;/code&gt; message can be used. This is also called &lt;em&gt;Duck typing&lt;/em&gt;, after the phrase &amp;quot;If it walks like a duck and quacks like a duck, it&#39;s a duck!&amp;quot;&lt;/p&gt;
&lt;p&gt;Either way, depending on abstractions is more &lt;em&gt;stable&lt;/em&gt; than depending on concretions, simply because a concretion is an &amp;quot;abstraction with the details filled in&amp;quot;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;E.g. depending on &amp;quot;I&#39;m being passed an object that understand this method&amp;quot; is more abstract than creating concrete instance and sending arguments in concrete order...&lt;/li&gt;
&lt;li&gt;This is where interfaces come in, either explicit (strictly-typed languages) or implicit (Duck-typing)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;avoiding-dependent-laden-classes&quot; tabindex=&quot;-1&quot;&gt;Avoiding Dependent-Laden Classes &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Here, the author adds an important subtle point to the way we should think about classes with many dependents: It&#39;s obvious that, if you change a dependent-laden class, you&#39;ll get lots of ripple effects that might require related changes.
But what that means, in practice, is that even &lt;em&gt;having&lt;/em&gt; a dependent-laden class in the first place is bad, because you will be &lt;em&gt;very&lt;/em&gt; reluctant to touch it.&lt;/p&gt;
&lt;h3 id=&quot;finding-the-dependencies-that-matter&quot; tabindex=&quot;-1&quot;&gt;Finding the Dependencies that Matter &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This is a really cool section that drives home all the points made above.&lt;/p&gt;
&lt;p&gt;Consider all your code, all your classes, and put them in a scatter plot. The x-axis
represents how many dependents it has. The y-axis represents how likely it is to change.
That leaves us with four quadrants that we can discuss here:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Abstract Zone:&lt;/strong&gt;
This zone represents classes that rarely change but that have &lt;em&gt;lots&lt;/em&gt; of dependents.
Typically this zone includes abstract classes and interfaces (either the explicit ones in languages that need them, or the ones implicitly defined via duck typing).&lt;/p&gt;
&lt;p&gt;This is a &lt;em&gt;good&lt;/em&gt; zone: If we accept that classes &lt;em&gt;need&lt;/em&gt; to depend on other classes to get anything done, then we want these dependencies to cluster around classes that, at least, rarely change, which &lt;em&gt;probably&lt;/em&gt; means that these classes are more on the abstract side.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Concrete Zone:&lt;/strong&gt;
Not called that way in the book, but I like the name as it contrasts with the Abstract Zone. This quadrant has those classes that are quite likely to change but that have few or no dependents. This is also a &lt;em&gt;good&lt;/em&gt; zone: Through our thoughtful design, we have reduced the impact of the likely changes. How did we get rid of the dependents of the concrete classes? By extracting the abstract ideas behind the concrete classes and movign the dependents over to those abstractions!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Neutral Zone:&lt;/strong&gt;
Classes that are neither likely to change nor cause a lot of trouble if they were to change. Certainly nice to have, but there always has to be a certain amount of change and of dependency in our application, so the interesting stuff happens in the previous two zones.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The Danger Zone:&lt;/strong&gt;
Finally, we have the quadrant of classes that are likely to change &lt;em&gt;and&lt;/em&gt; that have many dependents. This is the place where coding horror and spaghetti code live: Frequent changes that break lots of things make programming a nightmare. Be aware when you run into a class like this and consider if you can tackle it via reversing the direction of dependency, or extracting an abstract interface.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-11-18-poodr-chapter-3/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Not much to add to what the author already summarises so I won&#39;t plagiarize his excellent summary :)&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 2</title>
		<link href="https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/"/>
		<updated>2020-10-30T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/</id>
		<content type="html">&lt;p&gt;This is the second post in my book review / book notes series about &amp;quot;Practical Object Oriented Design&amp;quot; by Sandi Metz. (https://www.poodr.com/)&lt;/p&gt;
&lt;p&gt;In the last chapter we learned that design is all about writing code that is easy to change.&lt;/p&gt;
&lt;p&gt;In this chapter we will learn about one important principle that gets right to the core of this principle: Designing classes with a &lt;strong&gt;single responsibility&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;What makes writing good classes so tricky is the great fluidity they afford. There is only a handful ways to write your for-loops and if-clauses such that they actually perform the algorithm you want them to. There are a myriad ways to arrange functionality across classes.&lt;/p&gt;
&lt;p&gt;Some of the questions that arise are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What are your classes, i.e. by what concepts is code organized in your program?&lt;/li&gt;
&lt;li&gt;What behavior will they implement? What are the class&#39;s responsibilities?&lt;/li&gt;
&lt;li&gt;What does one class need to know about another class, i.e. what are the dependencies?&lt;/li&gt;
&lt;li&gt;What internal data does a class reveal to other classes, what is kept hidden?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As was discussed in the previous chapter, there&#39;s really two main requirements that dictate what this arrangement should be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The application should work &lt;em&gt;right now&lt;/em&gt; and do what it&#39;s supposed to do.&lt;/li&gt;
&lt;li&gt;The application should also be &lt;em&gt;easy to change later&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These requirements can be at odds sometimes, especially when a deadline looms. But here is a great quote from the book:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Your application needs to work right now just once; it must be easy to change forever.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;what-does-easy-to-change-mean&quot; tabindex=&quot;-1&quot;&gt;What does Easy to Change mean? &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Okay, so we agree that code should be easy to change. But what does that concretely mean, and how do we create code that actually &lt;em&gt;is&lt;/em&gt; easy to change? Here I want to dig a bit deeper into the author&#39;s definition.&lt;/p&gt;
&lt;h2 id=&quot;transparent&quot; tabindex=&quot;-1&quot;&gt;Transparent &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In complicated, tangled code (so-called spaghetti code), a seemingly benign change in one corner of the program has unexpected and detrimental consequences in a completely unrelated corner of the program. Often this happens when code depends on obscure implementation details and thus becomes fragile.&lt;/p&gt;
&lt;p&gt;Code that is easy to change should therefore be &lt;strong&gt;transparent&lt;/strong&gt;. You should be able to look at a proposed change and see what it will do to the code immediately around it, but also to code far away.&lt;/p&gt;
&lt;h2 id=&quot;reasonable&quot; tabindex=&quot;-1&quot;&gt;Reasonable &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The author asserts that small changes in requirements should require correspondingly small changes in code. This can be a bit tricky in scientific scenarios (see, e.g., https://xkcd.com/1425/). &lt;em&gt;Small&lt;/em&gt; is thus a somewhat vague term and what counts as a small change in requirements is not always obvious.&lt;/p&gt;
&lt;p&gt;However, what we can demand is that &lt;em&gt;if&lt;/em&gt; a small change in requirements needs big changes in code, this should be due entirely to the nature of the changes and not due to the nature of the way the code is arranged. The new or adjusted feature might require a lot of coding, but once that is done we should be able to neatly drop it into place without much fuss.&lt;/p&gt;
&lt;h2 id=&quot;usable&quot; tabindex=&quot;-1&quot;&gt;Usable &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The code that already exists should be easy to re-use. Often, new requirements are just small tweaks or recombinations of existing behavior. The better the code is designed, the easier it is to get at these pieces and combine them in useful ways.&lt;/p&gt;
&lt;h2 id=&quot;exemplary&quot; tabindex=&quot;-1&quot;&gt;Exemplary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Here the author says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the easiest way to make a change is to add code that in itself is easy to change&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So basically, write code that is good in a way that it inspires other developers (or future-you) to &lt;em&gt;also&lt;/em&gt; write good code, i.e. code that is easy to change.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;These code qualities spell out &amp;quot;TRUE&amp;quot;. Code that is TRUE will be easy to change and adapt to new requirements. So far so good in that we now have a few more concrete definitions to attach to our idea of &amp;quot;easy to change&amp;quot; code. That still leaves the question of &lt;em&gt;how&lt;/em&gt; we arrange our code such that it is true.&lt;/p&gt;
&lt;p&gt;Each design principle will touch on all of the TRUE qualities. The very first step, according to the author, is to ensure that your code adheres to the &lt;strong&gt;Single Responsibility Principle&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;creating-classes-that-have-a-single-responsibility&quot; tabindex=&quot;-1&quot;&gt;Creating Classes That Have a Single Responsibility &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Let&#39;s put aside for a moment the question of what exactly counts as a responsibility and just accept the fact that the stuff a class does fulfills one or more responsibilities.&lt;/p&gt;
&lt;p&gt;The Single Responsibility Principle (SRP) then states that a class should have a single responsibility. You might say each class should do one small useful thing and not more.&lt;/p&gt;
&lt;p&gt;Now how does that help in making your classes TRUE? Let&#39;s have a look.&lt;/p&gt;
&lt;h2 id=&quot;transparent-1&quot; tabindex=&quot;-1&quot;&gt;Transparent &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A change in a class with a single responsibility will affect how that responsibility is handled, and nothing else. This limits the unexpected consequences of a change, though it is not a silver bullet. You can still write badly tangled code that adheres to the SRP.&lt;/p&gt;
&lt;h2 id=&quot;reasonable-1&quot; tabindex=&quot;-1&quot;&gt;Reasonable &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If you have a bunch of responsibilities and a bunch of classes, and each class has exactly one responsibility, it follows mathematically that each responsibility is fulfilled by exactly one class.&lt;/p&gt;
&lt;p&gt;So if you want to make a small change to your application, you will only be dealing with a small number of behaviors that you need changed, and that means you will only be modifying a small number of classes. The smaller the change, the fewer classes will be affected. This is great! Compare this to spaghetti code where a seemingly small change requires each and every class to be changed.&lt;/p&gt;
&lt;h2 id=&quot;usable-1&quot; tabindex=&quot;-1&quot;&gt;Usable &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This quality most clearly benefits from adhering to the SRP. If each class has exactly one responsibility, it is much easier to re-use it in a different context than if it was carrying with it a bunch of responsibilities. Let me use a concrete example:&lt;/p&gt;
&lt;p&gt;I was reviewing code I had written some time ago for a project and there was a class that performed a certain data transformation step (&amp;quot;raw&amp;quot; problem input to a specific formulation of the problem that would then be passed on to a solver). But it &lt;em&gt;also&lt;/em&gt; performed the loading from file of that raw problem input. Now I wanted to re-use the problem transformation capability in a new context but that was very awkward, because that whole file-loading stuff wanted to come along for the ride. And it wasn&#39;t even &amp;quot;just there&amp;quot; and could be ignored. Rather, the way you created an instance of that whole problem-loader-and-transformer was to pass in the filename of the raw problem data. No way for me to say &amp;quot;Wait, I already have the data loaded, I just want to make that transformer class!&amp;quot;&lt;/p&gt;
&lt;p&gt;This is the case more often that not: If a class has more than one responsibility, they will be strongly entangled. Because if they weren&#39;t, you&#39;d probably already have split everything neatly into two classes!&lt;/p&gt;
&lt;h1 id=&quot;but-what-are-responsibilities&quot; tabindex=&quot;-1&quot;&gt;But What Are Responsibilities? &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;We have seen why a well-designed class has only a single responsibility. But what counts as a responsibility? If we want to be narrow and nitpicky, then every method implemented by a class is a responsibility: &amp;quot;Respond to that message&amp;quot;. By that logic, a class should have only one (public) method. Clearly that cannot be right.&lt;/p&gt;
&lt;p&gt;On the other hand, if we pick our idea of responsibility too broadly, the whole concept becomes meaningless: &amp;quot;My class is responsible for life, the universe, and all the rest.&amp;quot;&lt;/p&gt;
&lt;p&gt;So let&#39;s try and come up with a better concept of responsibility. A class&#39;s responsibilities are fulfilled by the class&#39;s methods, where each method implements a certain &lt;em&gt;behavior&lt;/em&gt;. These behaviors should form a &lt;em&gt;cohesive&lt;/em&gt; set, all aligned with a single, small responsibility.&lt;/p&gt;
&lt;p&gt;Since so much hinges on the class&#39;s methods, let&#39;s go on a quick detour about them&lt;/p&gt;
&lt;h2 id=&quot;the-single-responsibility-principle-for-methods&quot; tabindex=&quot;-1&quot;&gt;The Single Responsibility Principle for Methods &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Both in the &amp;quot;Practical Object Oriented Programming&amp;quot; and in the classic &amp;quot;Clean Code&amp;quot; by Robert &amp;quot;Uncle Bob&amp;quot; Martin the authors discuss the importance of writing functions (and thus methods) that do &lt;em&gt;one thing&lt;/em&gt;, not more. The same reasons apply as for classes: Doing more than one thing makes everything that much more complicated, entangled, and less useful.&lt;/p&gt;
&lt;p&gt;I highly recommend checking out the chapter on functions in &amp;quot;Clean Code&amp;quot; and internalizing these principles. It is an immediate win for your code quality if you start writing shorter, more focused function that do one thing, and one thing only. Bonus points if that one thing is clearly discernible from the function&#39;s name.&lt;/p&gt;
&lt;p&gt;Now while writing functions that way is a great idea in its own right, it becomes especially important when you want your class&#39;s methods to guide you to a better design: If each method does &lt;em&gt;one&lt;/em&gt; clearly defined thing, then you can easily tell whether your class fulfills more than one responsibility or not. If instead lots of behavior is crammed into a single method, it is hard to tell whether the class with that method is fulfilling a single responsibility or not.&lt;/p&gt;
&lt;h2 id=&quot;some-tests-for-methods-and-where-they-belong&quot; tabindex=&quot;-1&quot;&gt;Some Tests for Methods and Where They Belong &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once you have made sure that the methods itself are well-written with a single responsibility per method, you can use a few tests to see whether the method indeed belongs in the class it is currently in:&lt;/p&gt;
&lt;h3 id=&quot;the-interrogation-test&quot; tabindex=&quot;-1&quot;&gt;The &amp;quot;Interrogation&amp;quot; Test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If we view methods as &amp;quot;messages&amp;quot; that an object responds to, you can view them as questions or commands. So pretend that your class is a person and, for each of its methods, make that command or ask that question.&lt;/p&gt;
&lt;p&gt;As a concrete example, I remember in one of my projects we had a class &lt;code&gt;SchedulingProblem&lt;/code&gt; that was meant to represent the &amp;quot;Problem&amp;quot; from the end user&#39;s point of view. During a code review, I found that someone had added a &lt;code&gt;get_number_of_processors()&lt;/code&gt; method to it, for the purpose of parallelizing some calculation. I could certainly see how it was convenient to add that method there. But using the interrogation test, &amp;quot;Dear Mr. Scheduling Problem, how many processors do you have?&amp;quot; doesn&#39;t quite make sense.&lt;/p&gt;
&lt;h3 id=&quot;the-summary-test&quot; tabindex=&quot;-1&quot;&gt;The &amp;quot;Summary&amp;quot; Test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Try summarizing what the class does, or is responsible for, in a single sentence or maybe paragraph. Can you do it without using &amp;quot;and&amp;quot;/&amp;quot;or&amp;quot;?&lt;/p&gt;
&lt;p&gt;To quote from the book, if you have to use &amp;quot;and&amp;quot; there&#39;s a chance your class is responsible for two things. If you have to use &amp;quot;or&amp;quot;, chances are not only is your class responsible for two things, these two things aren&#39;t even that closely related!&lt;/p&gt;
&lt;h3 id=&quot;the-cohesion-test&quot; tabindex=&quot;-1&quot;&gt;The Cohesion Test &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Cohesion, in the context of Object Oriented Design, measures how much each method of a class operates on that class&#39;s attributes. Consider this, admittedly, very tiny example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Stack:
  def __init__(self):
    self._internal_list = []
	
  def pop(self):
    value = self._internal_list[-1]
	del self._internal_list[-1]
	
  def push(self, value):
    self._internal_list.append(value)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each method of this class interacts with the class&#39;s only attribute. Such a class would be considered maximally cohesive. It is neither required nor desirable to always achieve 100% cohesion in a real-world class. However, low cohesion often points at potential problems.&lt;/p&gt;
&lt;p&gt;Often you will find that you can group the class attributes together based on which subset of methods operates on them. This is a clear sign that your class wants to be broken up into two classes. Sometimes it is a clean break where one group of methods only accesses one group of attributes. But even if the break isn&#39;t clean, you can still improve the design by going from one class to two classes that now might need to share some information via methods.&lt;/p&gt;
&lt;h2 id=&quot;when-to-make-design-decisions&quot; tabindex=&quot;-1&quot;&gt;When to Make Design Decisions &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This is a great section in the book. Especially at the beginning of a programming project, or at the start of adding a whole new set of functionality, you might end up with a class where you feel that its design isn&#39;t quite right. But you also have no clue how to improve it because so little is known about how it will change in the future.&lt;/p&gt;
&lt;p&gt;At this point, you should weight the cost of trying (guessing, really) at the perfect design for a potential future change versus the cost of doing nothing now and leaving the decision for later, when more information arrives. The whole point of good design is to reduce the cost of future changes; so if doing &amp;quot;something&amp;quot; right now doesn&#39;t help reduce that cost, just don&#39;t bother.&lt;/p&gt;
&lt;p&gt;The only small issue then is that others might look at your currently imperfect class and think it&#39;s &amp;quot;okay&amp;quot; to code in that style. So maybe you &lt;em&gt;should&lt;/em&gt; improve the design right now? But then again, we lack the good information as to how.&lt;/p&gt;
&lt;h1 id=&quot;writing-code-that-embraces-change&quot; tabindex=&quot;-1&quot;&gt;Writing Code That Embraces Change &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;This section steps away from the overall &amp;quot;single responsibility principle&amp;quot; for a moment to discuss how you can solve the dilemma of having to write changeable code in a way that doesn&#39;t already pressupose &lt;em&gt;what&lt;/em&gt; the change will be.&lt;/p&gt;
&lt;p&gt;I will only briefly comment on them. The description are fine as they are, but there&#39;s a twist in Python.&lt;/p&gt;
&lt;h2 id=&quot;depend-on-behavior-not-data&quot; tabindex=&quot;-1&quot;&gt;Depend on Behavior, Not Data &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To summarize:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Behavior is captured in methods; it&#39;s in the &lt;em&gt;messages&lt;/em&gt; you send an object.&lt;/li&gt;
&lt;li&gt;If your class has a single responsibility, every behavior is contained in one, and only one, place&lt;/li&gt;
&lt;li&gt;Thus if you depend on behavior, your code can tolerate change because there&#39;s exactly one place to look for a particular behavior&lt;/li&gt;
&lt;li&gt;Classes also contain &lt;em&gt;data&lt;/em&gt;, contained in the &lt;em&gt;instance variables&lt;/em&gt;. Don&#39;t depend on data!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Why not depend on data? Because that &amp;quot;leaks out&amp;quot; the internal details of your class and means that you cannot change how the class deals with that data to produce behavior; other classes have taken it on themselves to add behavior to that data.&lt;/p&gt;
&lt;h3 id=&quot;hide-instance-variables&quot; tabindex=&quot;-1&quot;&gt;Hide Instance Variables &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The way in most programming languages to achieve this &lt;em&gt;encapsulation&lt;/em&gt; is to declare all instance variables as &lt;em&gt;private&lt;/em&gt; and only provide access via getter/setter functions (if at all!).&lt;/p&gt;
&lt;p&gt;In Python, things work a bit differently. First, there are no &lt;em&gt;true&lt;/em&gt; private instance attributes. It is merely accepted convention that attributes (and methods) of a class that begin with an underscore are &lt;em&gt;considered&lt;/em&gt; private implementation details and &lt;em&gt;should not&lt;/em&gt; be relied upon.&lt;/p&gt;
&lt;p&gt;When it comes to public attributes, Python has a nice feature in the &lt;code&gt;@property&lt;/code&gt; decorator that allows a seamless switch from attribute to getter/setter. Consider this simple example:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; radius&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; radius
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;compute_circumference&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;radius &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; math&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;pi&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Someone who uses the circle class can happily access (and set) the radius by directly accessing the attribute: &lt;code&gt;my_circle.radius = 3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;What if, for whatever reason, we want to change the way the circle is internally handled, and store the diameter instead of the radius? In many other programming languages, the fact that external code directly refers to &lt;code&gt;radius&lt;/code&gt; means we cannot easily change it to something like &lt;code&gt;get_radius()&lt;/code&gt;. In Python, however, we can just change it from an attribute to a property:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Circle&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; radius&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;diameter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; radius
		
	&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@property&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;radius&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;diameter &lt;span class=&quot;token operator&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;
	
	&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@radius&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;setter&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;radius&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; new_radius&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;diameter &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; new_radius&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So when should we use these properties and when should we use functions with explicit names like &lt;code&gt;get_radius()&lt;/code&gt;? Ideally, our class structure allows us to mostly rely on invoking behavior through methods, so we should not be dealing with too many attributes to begin with! Our first instinct should always be to hide data and let the classes work it out via methods that invoke behavior. Tell, don&#39;t ask! If it is indeed necessary to expose a class&#39;s attributes, we can start with the simple, direct attribute way and change to the property decorator later, if necessary. For &lt;em&gt;complex caluclations&lt;/em&gt;, I suggest making explicit that something is being computed or retrieved etc. Something behind a property should be just a simple lookup or conversion!&lt;/p&gt;
&lt;h3 id=&quot;hide-data-structures&quot; tabindex=&quot;-1&quot;&gt;Hide Data Structures &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Let&#39;s talk about DRY. It&#39;s another one of these important design principles, and stands for &lt;strong&gt;Don&#39;t Repeat Yourself&lt;/strong&gt;. Every bit of knowledge should have one definite place where it is defined. Some obvious cases of DRY-violations are lines of code that are copy-pasted instead of being extracted into a function. Some cases are more subtle.&lt;/p&gt;
&lt;p&gt;Consider this class:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SomeContainerForTimes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_data &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; data
		
	&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@property&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_data
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;convert_to_minutes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
		
	&lt;span class=&quot;token comment&quot;&gt;# ... lots more methods that explicitly refer item[0] and item[1]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So here we have some class that stores a list of tuples and apparently the first position refers to hours and the second position refers to minutes. And then there&#39;s lots of methods in that class who explicitly make use of that arrangement.&lt;/p&gt;
&lt;p&gt;This is a violation of the DRY principle! The fact that &amp;quot;hours are stored in position 0&amp;quot; is a piece of &lt;em&gt;knowledge&lt;/em&gt; which, therefore, should have only &lt;em&gt;one&lt;/em&gt; place where it is represented, instead of plastered all over the place. Whenever the data structure would change, each piece of code that uses the structure also needs to change, and that goes for internal and external uses of the &lt;code&gt;data&lt;/code&gt; array. For example, if we were to expand the code so in addition to hours and minutes it also contains days, we&#39;d probably want to have the days stored at position 0, hours at position 1 and minutes at position 2. Now we&#39;d have to find every use of &lt;code&gt;item[i]&lt;/code&gt; and update it so it uses the correct index. There&#39;s a big chance we&#39;d introduce bugs that way.&lt;/p&gt;
&lt;p&gt;What&#39;s a solution here? Encapsulate the raw data structure in something more descriptive:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; namedtuple
Time &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; namedtuple&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Time&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;hours&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;minutes&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;SomeContainerForTimes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_times &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_convert_raw_array&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
		
	&lt;span class=&quot;token decorator annotation punctuation&quot;&gt;@property&lt;/span&gt;
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; times&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;_times
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;_convert_raw_array&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;Time&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;hours&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; minutes&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;item&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; data&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
	
	&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;convert_to_minutes&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;60&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;hours &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; item&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;minutes &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; self&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;times&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;
	
	&lt;span class=&quot;token comment&quot;&gt;# ... lots more methods that now make reference &lt;/span&gt;
	&lt;span class=&quot;token comment&quot;&gt;#     to item.hours and item.minutes&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now the &lt;em&gt;knowledge&lt;/em&gt; that &lt;code&gt;item[0]&lt;/code&gt; contains hours and &lt;code&gt;item[1]&lt;/code&gt; contains minutes is stored in only one place: The &lt;code&gt;_convert_raw_array&lt;/code&gt; method. Every other method (even inside the same class) will now refer to the &lt;code&gt;_times&lt;/code&gt; list instead of the raw array.&lt;/p&gt;
&lt;p&gt;I&#39;ll just quote the book here as it&#39;s spot on:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Direct references into complicated structures are confusing, because they obscure what the data really is, and they are a maintenance nightmare, because every reference will need to be changed when the structure of the array changes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A note about Python: There, we have the built-in &lt;code&gt;dict&lt;/code&gt; type which is similar to an array except that keys can be any hashable object. We &lt;em&gt;could&lt;/em&gt; have used a &lt;code&gt;dict&lt;/code&gt; instead of a &lt;code&gt;namedtuple&lt;/code&gt; here, and at least it would have made the structure more clear (we&#39;de be using &lt;code&gt;data[&amp;quot;hours&amp;quot;]&lt;/code&gt; and &lt;code&gt;data[&amp;quot;times&amp;quot;]&lt;/code&gt;) and extensible.&lt;/p&gt;
&lt;p&gt;It may be a matter of taste, but I prefer the &lt;code&gt;namedtuple&lt;/code&gt; here over a solution with &lt;code&gt;dict&lt;/code&gt;. I feel that a &lt;code&gt;dict&lt;/code&gt; is best used as an &amp;quot;array&amp;quot; with advanced keys. In particular, it is useful where we don&#39;t know in advance what the keys are. For our time object, we need &lt;code&gt;hour&lt;/code&gt; and &lt;code&gt;minutes&lt;/code&gt; and that&#39;s it. Declaring a named tuple makes this explicit. It should also have a smaller footprint than a &lt;code&gt;dict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An added benefit is that the syntax for item access of the &lt;code&gt;namedtuple&lt;/code&gt; makes it easy to later change it to a full-blown class in case we want to add behavior to the &lt;code&gt;Time&lt;/code&gt; object.&lt;/p&gt;
&lt;h3 id=&quot;enforce-single-responsibility-everywhere&quot; tabindex=&quot;-1&quot;&gt;Enforce Single Responsibility Everywhere &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;I have already touched upon the points of this subsection in the &amp;quot;Single Responsibiltiy Principle for Methods&amp;quot; section. I cannot emphasize enough how radically transformative your coding becomes once you start &lt;em&gt;radically&lt;/em&gt; enforcing this principle and write methods that truly do one thing only!&lt;/p&gt;
&lt;p&gt;Let&#39;s recap what the author thinks about these qualities. Methods with single responsibilities have these benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Expose previously hidden qualities&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I touched on this above; once all your &lt;em&gt;methods&lt;/em&gt; have a single responsibility, you can then determine whether your &lt;em&gt;class&lt;/em&gt; has a single responsibility simply by looking at the methods.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Avoid the need for comments&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Another great chapter in Clean Code talks about comments. As a novice programmer, I thought more is better when it comes to comments. I have since learned that comments are often used as deodorant to mask &lt;em&gt;code smells&lt;/em&gt;. If you feel like you should write a comment, try and improve the code instead so the comment becomes unnecessary. One such way is to take the code that had the comment and extract it into a single method, with the name of the method replacing the comment.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Encourage reuse&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If your method combines reading some data &lt;em&gt;and&lt;/em&gt; processing the data, the only way to reuse the method is to also read data &lt;em&gt;and&lt;/em&gt; processing it. What if you wanted to reuse only the processing part, or the reading part? When you write your small single-responsibility methods, you will create many small methods that form the &lt;em&gt;building blocks&lt;/em&gt; for the higher levels of functionality. It is these building blocks that will make your code easy to reuse &lt;em&gt;without&lt;/em&gt; copy-pasting.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Are easy to move to another class&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the spirit of designing code that is amenable to change, small methods are easier to move to another class than large methods. This encourages you to improve your design, because it lowers the barrier to such refactorings.&lt;/p&gt;
&lt;h3 id=&quot;nested-classes&quot; tabindex=&quot;-1&quot;&gt;Nested Classes &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The book chapter closes with a section on isolating behavior inside classes. Basically, if you feel that certain methods do not belong in the class they are currently in, but you don&#39;t know yet where they &lt;em&gt;should&lt;/em&gt; belong, you can create an &lt;em&gt;internal&lt;/em&gt; (or &lt;em&gt;nested&lt;/em&gt;) class inside your current class and move them there. Then at least they&#39;re not muddying the class, and once you have more information about what design you want, the nested class will be easier to extract.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-30-poodr-chapter-2/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;This was a big chapter and explained one of the foundational principles. At this point it might still be rather abstract. The principles of single responsibility and not repeating yourself should appear agreeable enough, but I hope in subsequent posts to provide more &lt;em&gt;concrete&lt;/em&gt; examples of what we might consider to be a responsibility and how to write our classes such they only have one.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Practical Object Oriented Design - Book Notes - Chapter 1</title>
		<link href="https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/"/>
		<updated>2020-10-02T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/</id>
		<content type="html">&lt;p&gt;This is the first post in what I hope to be a series of posts, discussing my experience and thoughts with reading the excellent book, &lt;a href=&quot;https://www.poodr.com/&quot;&gt;&amp;quot;Practical Object Oriented Design&amp;quot;&lt;/a&gt;, by Sandi Metz. This is mostly so I can internalize the great lessons from the book, and the best way to do that is to try and explain those lessons to others.&lt;/p&gt;
&lt;p&gt;The book itself uses Ruby as the programming language of choice to explore the principles of good object oriented design. My own examples will be from Python as that is what I am using at work.&lt;/p&gt;
&lt;p&gt;Let us now dive right into the first chapter.&lt;/p&gt;
&lt;h1 id=&quot;what-is-object-oriented-design-all-about&quot; tabindex=&quot;-1&quot;&gt;What is Object Oriented Design all About? &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Old-school programming languages like FORTRAN and C are &lt;em&gt;procedural&lt;/em&gt; languages. The programs are a set of step-by-step instructions, and these instructions operate on data.&lt;/p&gt;
&lt;p&gt;In object-oriented programming languages, you instead view the world as being made up of objects that interact with each other by &lt;em&gt;sending messages&lt;/em&gt;. In technical terms, your objects are described by classes, and sending a message means calling a class&#39;s method.&lt;/p&gt;
&lt;p&gt;When attempting object-oriented design (OOD), you need to shift your perspective away from procedures and modules towards these objects and messages. Merely taking procedural code and slapping classes around the functions does &lt;em&gt;not&lt;/em&gt; make it object oriented.&lt;/p&gt;
&lt;h1 id=&quot;what-is-design-good-for-anyway&quot; tabindex=&quot;-1&quot;&gt;What is Design Good for Anyway? &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Here is an uplifting quote from the book&#39;s first chapter:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The programming techniques that make code a joy to write overlap with those that most efficiently produce software.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So what makes code a joy to write? Code that is clear and logical and easy to work with. In particular, code that is easy to &lt;em&gt;change&lt;/em&gt;. A big point of the book, especially given it&#39;s subtitle &amp;quot;An Agile Primer&amp;quot;, is that it is guaranteed that your program will have to change. Maybe requirements weren&#39;t clear at the start. Maybe the program was a success and now enthusiastic clients are asking for additional features. Whatever the reason, you will need to change your code.&lt;/p&gt;
&lt;p&gt;And if your program is anything but short-lived, the time spent &lt;em&gt;modifying&lt;/em&gt; the program is far greater than the time spent on the initial writing.&lt;/p&gt;
&lt;p&gt;So then design is about solving the problem of writing code that is easy to change. It&#39;s not about dazzling your coworkers with intricate patterns or architectures.&lt;/p&gt;
&lt;h2 id=&quot;why-change-is-hard&quot; tabindex=&quot;-1&quot;&gt;Why Change is Hard &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The book goes on to explain &lt;em&gt;why&lt;/em&gt; change is hard and can introduce problems when the code is not designed well:&lt;/p&gt;
&lt;p&gt;Looking at your object-oriented program, you have a bunch of objects that send each other a bunch of messages to produce the desired behaviour. For that to work, your objects need to know certain things about each other: Who to send what message to and in what format?&lt;/p&gt;
&lt;p&gt;While this knowledge is necessary to get any work done, it also creates &lt;em&gt;dependencies&lt;/em&gt;. It is these dependencies that stand in the way of change: If class A depends on class B being &amp;quot;just so&amp;quot;, then a change to class B forces a change in class A. Before you know it, these forced changes have rippled through the entire program.&lt;/p&gt;
&lt;p&gt;Good object-oriented design is all about &lt;em&gt;managing&lt;/em&gt; these dependencies. We can never completely get rid of them, but by making careful choices about the design we can limit them to the absolute minimum.&lt;/p&gt;
&lt;h2 id=&quot;a-practical-definition-of-design&quot; tabindex=&quot;-1&quot;&gt;A Practical Definition of Design &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I remember back in university, a fellow Physics student ask me (because I also took Comp Sci classes) what classes were actually for, since he was convinced you could achieve any conceivable bit of functionality just as well without them. I did not have a good reply back then because, &lt;em&gt;technically&lt;/em&gt; he was right. Classes are not so much about providing functionality as they are about organizing that functionality.&lt;/p&gt;
&lt;p&gt;Sandi Metz has a very simple, practical definition of design:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every application is a collection of code; the codes arrangement is the design.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;As an example of bad design, I remember my first days of learning Visual Basic 6 in high school. You had a nice drag and drop editor for user interfaces, and the control elements like clickable buttons had event-based methods like &lt;code&gt;on_click()&lt;/code&gt; that the runtime environment would call for you when you actually clicked the button.&lt;/p&gt;
&lt;p&gt;These event methods were where I put &lt;em&gt;all&lt;/em&gt; the application code and business logic of my programs. In terms of functionality, my programs did exactly what I wanted them to do. But when I wanted to change the user interface, I also had to carefully rearrange where the internal workings of the program took place. Truly hard work, and an example of code that&#39;s maybe not arranged in the best possible way.&lt;/p&gt;
&lt;p&gt;This example demonstrates that code has two potentially conflicting demands: Obviously, it must solve the problem that it&#39;s meant to solve. But it must &lt;em&gt;also&lt;/em&gt; be written in such a way that it can easily incorporate future changes.&lt;/p&gt;
&lt;p&gt;Here it is important to make a distinction: Anticipating &lt;em&gt;change&lt;/em&gt; is not the same as anticipating &lt;em&gt;one particular future change&lt;/em&gt; and then pre-emptively accounting for that anticipated change. We cannot see the future and we cannot guess what additional features or requirements we will face. That is not what design is about. Instead, it is about leaving the code &amp;quot;room to breathe&amp;quot; so that &lt;em&gt;whatever&lt;/em&gt; change actually arrives in the future can be easily incorporated.&lt;/p&gt;
&lt;h1 id=&quot;the-tools-of-design&quot; tabindex=&quot;-1&quot;&gt;The Tools of Design &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Next, the author talks about two tools in the kit of a software engineer: Design Principles and Design Patterns. Let&#39;s take a look.&lt;/p&gt;
&lt;h2 id=&quot;design-principles&quot; tabindex=&quot;-1&quot;&gt;Design Principles &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While design involves judgement calls, tradeoffs, and some subjective assessments, there are certain guiding principles that have emerged and become evident over the years. There is academic evidence that following these principles makes your code better (i.e., easier to change). In the course of the boook, the author will touch on many of them and go in-depth. The most famous principles are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SOLID: Single Responsibility, Open-Closed, Liskov-Substitution, Interface Segregation and Dependency Inversion (or Injection)&lt;/li&gt;
&lt;li&gt;DRY (Don&#39;t Repeat Yourself)&lt;/li&gt;
&lt;li&gt;Law of Demeter (LoD)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I won&#39;t expand on them here. Stay tuned for more on them, though.&lt;/p&gt;
&lt;h2 id=&quot;design-patterns&quot; tabindex=&quot;-1&quot;&gt;Design Patterns &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Some problems in object-oriented design come up time and again, and so the &amp;quot;Gang of Four&amp;quot; (Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides) wrote a book called &amp;quot;Design Patterns&amp;quot; where they present &amp;quot;simple and elegant solutions to specific problems in object-oriented software design&amp;quot;. They have names like Singleton, Factory, Command, Adapter, Decorator, Strategy etc and are a great tool in every programmers toolbox.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beware&lt;/strong&gt; though: Many novice programmers, myself included, get overzealous when they first learn about patterns. In an attempt to appear sophisticated, they then try and cram patterns into every bit of code no matter how misplaced the pattern actually is. Use the right tool for the job!&lt;/p&gt;
&lt;h1 id=&quot;the-act-of-design&quot; tabindex=&quot;-1&quot;&gt;The Act of Design &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Now the author explains how and when to design, and first explains how design can fail. For that, there&#39;s basically two failure modes at the extremes: Too little design, or too much design.&lt;/p&gt;
&lt;p&gt;With too little design, your application quickly devolves into spaghetti code. There&#39;s a good chance that every programmer is familiar with this problem, because every programmer started out as a novice who didn&#39;t know the least bit about design.&lt;/p&gt;
&lt;p&gt;On the other hand, there&#39;s too much design. That&#39;s the aforementioned pattern zealot, or someone who wraps every little bit of code in ten layers of abstraction and indirection.&lt;/p&gt;
&lt;p&gt;There&#39;s another failure mode: Separating the act of design from the act of programming. Sometimes derisively referred to as &amp;quot;Big Up-Front Design&amp;quot; (BUFD), the problem with it is that it severes the all-important feedback loop between programming and designing. Ideally, your design will evolve incrementally:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A small program is easy to write and easy to design well&lt;/li&gt;
&lt;li&gt;If you have a program that is designed well, it will be easy to change&lt;/li&gt;
&lt;li&gt;Adding a &lt;em&gt;small&lt;/em&gt; change to a well-designed program allows you to arrive at a well-designed slightly bigger program&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It follows that small, incremental steps are the ticket to arrive at a well-designed big program.&lt;/p&gt;
&lt;p&gt;In this agile sense, design is simply about maintaining your ability to easily incorporate the changes of the next iteration. It is vastly different from the BFUD where you try, in advance, to specify exactly where everything will go.&lt;/p&gt;
&lt;h1 id=&quot;judging-design&quot; tabindex=&quot;-1&quot;&gt;Judging Design &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Next up, the author discusses &lt;em&gt;metrics&lt;/em&gt; for design, such as class cohesion. There are tools that analyze your code and give you a score on certain metrics, but there&#39;s no clear-cut correlation between scores and code quality. You can have high scores and bad design, because you&#39;re only looking at proxy measures.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;true&lt;/em&gt; measure of a good design would be something like &amp;quot;cost per feature over the time interval that matters&amp;quot;. But this is incredibly hard to measure.&lt;/p&gt;
&lt;p&gt;What&#39;s this time interval thing? Well, when writing any feature, you are dealing with the trade-off of design and cost. Spending more time on making the design good costs time now, and delays the feature, but it reaps benefits further down the line in making other features cheaper to implement. There is an intricate balance: As the author points out, the advantage of having a feature done &lt;em&gt;right now&lt;/em&gt; might outweigh the costs associated with fixing a rushed design. It is also a matter of skill: If you are a skilled software engineer, the extra time taken to get the design right will be small, and thus your design efforts will reach a net positive effect rather early. If, on the other hand, you are a novice, you might spend a lot of time on a design that won&#39;t even be that good, and thus the effort might actually never pay off.&lt;/p&gt;
&lt;h1 id=&quot;summary&quot; tabindex=&quot;-1&quot;&gt;Summary &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-10-2-poodr-chapter-1/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Design is about arranging code such that it can efficiently accommodate change&lt;/li&gt;
&lt;li&gt;Code that is easy to change is a joy to work with&lt;/li&gt;
&lt;li&gt;Principles and patterns are tools, but how to apply them is an art, or a craft&lt;/li&gt;
&lt;li&gt;Avoid under- and overdesigning by understanding the theory of design and learning how to translate that into practice&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Next up, we will be looking at the first principle: The Single Responsibility Principle.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>The Law of Demeter - Don&#39;t let your classes micromanage each other</title>
		<link href="https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/"/>
		<updated>2020-02-19T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/</id>
		<content type="html">&lt;p&gt;Anyone who has ever worked with a micromanaging boss or supervisor knows how demoralizing and inefficient this can be. Instead of being asked to achieve results as they are defined in your role&#39;s responsibilities, such a boss tells you in excrutiating detail what steps you should follow.&lt;/p&gt;
&lt;p&gt;Nobody likes a micromanager, and the classes you write in an object oriented language are no different there! They are much happier if you tell them what to do, in terms of their responsibilities, rather than asking them for a detailed report of their internal state and then going off on a long chain of commands.&lt;/p&gt;
&lt;p&gt;This idea is not new, of course, and relates to two important, interlinked concepts: The Law of Demeter, and the &amp;quot;Tell, Don&#39;t Ask!&amp;quot; principle. Let&#39;s start with a brief introduction and summary of them and then expand on what it means for our code.&lt;/p&gt;
&lt;h2 id=&quot;the-law-of-demeter&quot; tabindex=&quot;-1&quot;&gt;The Law of Demeter &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This law (sometimes snarkily referred to as the &amp;quot;sometimes helpful suggestion&amp;quot; instead) states, at a high level, that your class should not talk to strangers. How does that look like? Suppose you have class, &lt;code&gt;C&lt;/code&gt;. That class has a method, &lt;code&gt;f&lt;/code&gt;. Inside of &lt;code&gt;f&lt;/code&gt; is a bunch of code. You might, for example, want to call some other methods from within &lt;code&gt;f&lt;/code&gt;. The Law of Demeter says that you are only allowed to call methods of the following objects:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; itself&lt;/li&gt;
&lt;li&gt;Objects passed to &lt;code&gt;f&lt;/code&gt; as arguments&lt;/li&gt;
&lt;li&gt;Any objects that were created or instantiated by &lt;code&gt;f&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Component objects (i.e., held in instance variables) of &lt;code&gt;C&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Anything else is considered off limits! In particular, if one of the methods that are permitted returns an object that&#39;s not in turn part of the permitted list, you cannot call any of its methods! Egregious violation of this law are referred to as &lt;em&gt;train wrecks&lt;/em&gt;, and you can recognize them by a lot of dots: &lt;code&gt;car.get_owner().get_address().get_postcal_code()&lt;/code&gt;. Yuck! You are micromanaging the application by asking the car to tell you who its owner is, which you then ask where they live, and the address then is supposed to hand you its postal code.&lt;/p&gt;
&lt;p&gt;This might sound overly strict, but I agree in large part with JavaDevGuy in his post &lt;a href=&quot;https://javadevguy.wordpress.com/2017/05/14/the-genius-of-the-law-of-demeter/&quot;&gt;The Genius of the law of Demeter&lt;/a&gt;: It is &lt;em&gt;the&lt;/em&gt; law of object oriented programming.&lt;/p&gt;
&lt;h3 id=&quot;why-is-this-bad-anyway&quot; tabindex=&quot;-1&quot;&gt;Why is this bad, anyway? &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When violating the LoD, you are sprinkling unrelated structural knowledge throught your code. Each part of the trainwreck is a piece of knowledge that you assume you have: &amp;quot;In this code, cars have owners, which have addresses, which have postal codes, and they are accessed through these particular methods.&amp;quot; Your trainwreck introduces coupling where it might not be wise to do so. This makes your application hard to change and, ultimately, leads to the famed and feared Spaghetti code.&lt;/p&gt;
&lt;h3 id=&quot;some-caveats-and-nuances&quot; tabindex=&quot;-1&quot;&gt;Some caveats and nuances &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Of course, nothing is ever quite as black and white, so let&#39;s unpack a few important points about the law.&lt;/p&gt;
&lt;p&gt;First, you can technically get around the law by introducing wrapper methods: You could add a method &lt;code&gt;getOwnerAddressesPostalCode()&lt;/code&gt; to the car object. But in a sense you&#39;re still violating the law. Maybe not its text, but definitely its spirit: You are still coupling a postal code to a car where it might be ill-advised.&lt;/p&gt;
&lt;p&gt;Second, contrary what you sometimes read on articles on the subject, the LoD is not &lt;a href=&quot;https://haacked.com/archive/2009/07/14/law-of-demeter-dot-counting.aspx/&quot;&gt;a dot-counting exercise&lt;/a&gt;. This cuts both ways: On the one hand, just because you don&#39;t have multiple dots per line doesn&#39;t mean you don&#39;t violate the law (see above&#39;s lengthy wrapper method). On the other hand, just because you &lt;em&gt;do&lt;/em&gt; have multiple dots per line doesn&#39;t mean you &lt;em&gt;are&lt;/em&gt; violating it. For starters, a method you call might be returning an object that, in turn, is on the list of allowed objects. This is an important feature of so-called &lt;em&gt;fluent&lt;/em&gt; interfaces. But even if an object doesn&#39;t strictly fall on above&#39;s list of allowed objects, it might still make sense to call methods on it: If that object is a &lt;em&gt;friend&lt;/em&gt; of yours.&lt;/p&gt;
&lt;p&gt;A clarification, relaxation and expansion of the Law of Demeter states that you can call the methods of any object you are &lt;em&gt;friends&lt;/em&gt; with. The objects in the original list above are all friends, but it doesn&#39;t stop there. Other examples of friendly classes are given in candied_orange&#39;s excellent &lt;a href=&quot;https://softwareengineering.stackexchange.com/a/322645/161522&quot;&gt;post&lt;/a&gt; on the topic:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Value objects are friendly with everyone. Especially if they are part of the domain you are writing for. Imagine trying to write code for a physics simulator where the Law of Demeter would prohibit you something like &lt;code&gt;wavefunction.amplitude.real&lt;/code&gt;. In scientific programming, a lot of the objects that you deal with will be value objects.&lt;/li&gt;
&lt;li&gt;Collections should be friendly with everyone who uses them: If your class holds a list, then clearly it should be able to call a method on the list to get to one of the list&#39;s items, and then call a method on these items.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;tell-don-t-ask&quot; tabindex=&quot;-1&quot;&gt;Tell, Don&#39;t Ask &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When faced with a situation where you feel you &lt;em&gt;must&lt;/em&gt; violate the Law of Demeter, there&#39;s a good chance the overall design is flawed. Sometimes, the violation can be resolvd in syntactic means:&lt;/p&gt;
&lt;p&gt;Imagine you have a method&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    b&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;get_a&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then you could instead add a method to &lt;code&gt;b&lt;/code&gt; that reads &lt;code&gt;b.tell_a_to_do_something()&lt;/code&gt;. Of course that might just be violating the law in spirit anyway, but sometimes it&#39;s perfectly appropriate to go this route of delegation.&lt;/p&gt;
&lt;p&gt;Alternatively, if method &lt;code&gt;f&lt;/code&gt; needs object &lt;code&gt;A&lt;/code&gt; to get its job done, it should ask for it as a parameter:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot; tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;self&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; b&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; a&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;
    a&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;do_something&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, a larger redesign of which objects exist and how they talk to each other might be in order. The guiding principle here goes back to the beginning of the post: Don&#39;t micromanage. What is it you want to accomplish? Whose responsibility is that? Tell them, but leave the execution details up to them!&lt;/p&gt;
&lt;p&gt;Another great StackOverflow &lt;a href=&quot;https://softwareengineering.stackexchange.com/a/284146/161522&quot;&gt;post&lt;/a&gt; by user candied_orange talks about the SOLID design principles. In particularly the &amp;quot;Single Responsibility Principle&amp;quot; and the &amp;quot;Dependency Invesion Principle&amp;quot; (more on these later, maybe?) take you in great strides towards code that automatically won&#39;t violate the Law of Demeter.&lt;/p&gt;
&lt;h1 id=&quot;conclusion&quot; tabindex=&quot;-1&quot;&gt;Conclusion &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-02-19-Law_of_demeter/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;At the very least, I hope to have convinced you that a long chain of method calls is a &lt;em&gt;code smell&lt;/em&gt; that warrants further investigation: Are we micromanaging here, or legitimatly using domain value objects? And could we improve our design, make it more adjustable and modular, in an attempt to remove the violation? A better design might very well result from that!&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Some common issues in feature-branch Github workflow</title>
		<link href="https://cadolphs.github.io/blog/2020-01-17-Github-workflow/"/>
		<updated>2020-01-17T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2020-01-17-Github-workflow/</id>
		<content type="html">&lt;p&gt;This article is a quick overview of the github workflow I currently use with my team. It is mostly for a quick reference to team members about what to do in some of the rarer situations.&lt;/p&gt;
&lt;h1 id=&quot;basic-setup&quot; tabindex=&quot;-1&quot;&gt;Basic setup &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Development happens in feature branches that are then squash-merged into a branch &lt;code&gt;develop&lt;/code&gt; after a pull request.&lt;/li&gt;
&lt;li&gt;Before sending a PR, a feature-branch should be &lt;strong&gt;rebased&lt;/strong&gt; onto &lt;code&gt;develop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;It is encouraged that PRs are small but complete.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;the-simplest-case&quot; tabindex=&quot;-1&quot;&gt;The simplest case &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Lets consider a branch &lt;code&gt;feature1&lt;/code&gt; with a bunch of commits to be merged into &lt;code&gt;develop&lt;/code&gt;. The easiest case has that branch live in isolation: no other branches branch off of &lt;code&gt;feature1&lt;/code&gt;.
In this case, all that needs to happen is:&lt;/p&gt;
&lt;p&gt;git checkout feature1
git rebase -i origin/develop   ## use this step to clean up commit history a bit
git push -f&lt;/p&gt;
&lt;p&gt;And then we create the pull request on github. If everybody is happy, it will be squashed and merged. The branch &lt;code&gt;feature1&lt;/code&gt; can now safely be deleted.&lt;/p&gt;
&lt;h2 id=&quot;what-squash-and-merge-does&quot; tabindex=&quot;-1&quot;&gt;What squash-and-merge does &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This takes all the commits from the feature branch, creates a new commit that contains all their collective changes, and applies that commit to the develop branch. That way, develop has one commit per pull request.
This also means that the two branches now diverge: &lt;code&gt;feature1&lt;/code&gt; has a bunch of commits, whereas &lt;code&gt;develop&lt;/code&gt; only has one commit. Git doesnt know that these are essentially the same changes. In the simple case, this doesnt matter, because were deleting &lt;code&gt;feature1&lt;/code&gt; anyway!&lt;/p&gt;
&lt;h1 id=&quot;hard-case-1-extra-development-after-rebase&quot; tabindex=&quot;-1&quot;&gt;Hard case 1: Extra development after rebase &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Consider this scenario: Branch &lt;code&gt;feature1&lt;/code&gt; has been rebased onto &lt;code&gt;develop&lt;/code&gt; and sent off for a pull request. After this step, a new branch &lt;code&gt;feature2&lt;/code&gt; was created off of &lt;code&gt;feature1&lt;/code&gt; to continue some development that relied on the new feature introduced in &lt;code&gt;feature1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579294479316_image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-1-pr-gets-accepted-without-changes&quot; tabindex=&quot;-1&quot;&gt;Case 1: PR gets accepted without changes &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Awesome work, no changes. So lets do the squash-merge. Remember, this creates a new commit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579294835786_image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;So far so good. Now lets say were done with our work on &lt;code&gt;feature2&lt;/code&gt; and want to rebase onto &lt;code&gt;develop&lt;/code&gt; prior to sending a pull request. If we do this naively, this is what happens:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579294937380_image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;YIKES.&lt;/strong&gt; Remember that, due to the squash-merge, commit C5 contains the work that was done in commits C2 and C3. But git doesnt keep track of that. So if we tell it to rebase &lt;code&gt;feature2&lt;/code&gt; onto &lt;code&gt;develop&lt;/code&gt;, it will grab &lt;em&gt;all&lt;/em&gt; commits from &lt;code&gt;feature2&lt;/code&gt; that werent part of develop. This means C2, C3, and C4. Then it creates new commits that apply those same changes onto &lt;code&gt;develop&lt;/code&gt;.
&lt;strong&gt;The correct way:&lt;/strong&gt;
In our case, we really only want the commit C4 to be taken from &lt;code&gt;feature2&lt;/code&gt; and applied to &lt;code&gt;develop&lt;/code&gt;. The way to achieve this is the &lt;code&gt;--onto&lt;/code&gt; option of &lt;code&gt;git rebase&lt;/code&gt;. Here is what we should have done:&lt;/p&gt;
&lt;p&gt;git checkout feature2
git rebase --onto develop feature1
git push -f&lt;/p&gt;
&lt;p&gt;What is this? It tells git to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Take those commits from &lt;code&gt;feature2&lt;/code&gt; that are ahead of &lt;code&gt;feature1&lt;/code&gt;. In this case, C4.&lt;/li&gt;
&lt;li&gt;Apply those commits as new commits to &lt;code&gt;develop&lt;/code&gt; instead of &lt;code&gt;feature1&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make &lt;code&gt;feature2&lt;/code&gt; point to the latest of those new commits.
&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579295868424_image.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(The git playground doesnt support these sophisticated commands, so instead of saying C4 it says C6).
Now C6 contains the changes of C4, but applied to develop.&lt;/p&gt;
&lt;h2 id=&quot;case-2-extra-changes-to-feature1&quot; tabindex=&quot;-1&quot;&gt;Case 2: Extra changes to feature1 &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579295694877_image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Here our PR in &lt;code&gt;feature1&lt;/code&gt; got accepted with some revisions. C6 now contains the work of C2, C3, and C5. On the other hand, &lt;code&gt;feature2&lt;/code&gt; has diverged from &lt;code&gt;feature1&lt;/code&gt;.
Theres two ways to deal with this. Lets do the one thats easier conceptually: If &lt;code&gt;C4&lt;/code&gt; was coming &lt;em&gt;after&lt;/em&gt; C5, we could use the solution of the previous chapter. So lets make it so:&lt;/p&gt;
&lt;p&gt;git checkout feature2
git rebase feature1
git rebase --onto develop feature1
git push -f&lt;/p&gt;
&lt;p&gt;The first two lines give&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579296061588_image.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;which is the same as in the previous chapter, so the rebase-onto works.&lt;/p&gt;
&lt;p&gt;But if we think about it for a bit, we could have skipped that intermediate step and just used the &lt;code&gt;rebase&lt;/code&gt; &lt;code&gt;--``onto&lt;/code&gt; from the start: Our first rebase grabs C4 and makes a new commit that makes it apply to &lt;code&gt;feature1&lt;/code&gt;. The next rebase grabs C4 and makes that apply to &lt;code&gt;develop&lt;/code&gt;. So why not just grab C4 and apply that directly to develop? So then the faster version is&lt;/p&gt;
&lt;p&gt;git checkout feature2
git rebase --onto develop feature1
git push -f&lt;/p&gt;
&lt;h1 id=&quot;hard-case-2-multiple-people-on-branch&quot; tabindex=&quot;-1&quot;&gt;Hard case 2: Multiple people on branch &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;There are several pitfalls with this, but they can all be avoided with proper care. Lets take a look:&lt;/p&gt;
&lt;h2 id=&quot;beware-the-rebase&quot; tabindex=&quot;-1&quot;&gt;Beware the rebase &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Rebasing a branch changes the commits in its history. Thats why, after a rebase, you have to push with the &lt;code&gt;-f&lt;/code&gt; (force!) option. It also means that, once its been pushed, anybody who was also working on that branch now has a local version thats in conflict with the remote version.
&lt;strong&gt;Important:&lt;/strong&gt; Before doing a rebase on a branch with multiple collaborators, let everybody know! Make sure everybodys local changes are integrated (see below) and all local branches are up to date with the origin. Then do the rebase and force-push. After that, everybody else needs to run&lt;/p&gt;
&lt;p&gt;git checkout branch_that_was_rebased
git fetch --all
git reset --hard origin/branch_that_was_rebased&lt;/p&gt;
&lt;p&gt;This makes your local version of the branch the same as the remote version that was just forcefully pushed&lt;/p&gt;
&lt;h2 id=&quot;don-t-create-a-bajillion-merge-commits&quot; tabindex=&quot;-1&quot;&gt;Dont create a bajillion merge commits &lt;a class=&quot;header-anchor&quot; href=&quot;https://cadolphs.github.io/blog/2020-01-17-Github-workflow/&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Lets say you and your buddy are working on the same branch (but on different files). You are constantly committing, pushing, and pulling. Now each time there were simultaneous commits and you do a git push / pull, youll create extra merge commits:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579297102356_image.png&quot; alt=&quot;Real work was done in C2 and C3, whereas C4 is just a merge commit&quot;&gt;&lt;/p&gt;
&lt;p&gt;The reason is this: You cant push your local branch to origin unless its a fast forward, i.e., theres no changes in the origin that you dont have locally. One way to get those remote changes is &lt;code&gt;git pull&lt;/code&gt;. This is nothing other than a &lt;code&gt;git merge&lt;/code&gt; of the remote commits into your local branch, so unless its again a simple fast-forward, itll create an extra merge commit. A productive coding session can create quite a few of those, and theyll needlessly clutter up the commit history.&lt;/p&gt;
&lt;p&gt;Ideally, we want merge commits to have real meaning, as in this new feature was developed in this branch and upon completion merged into our development branch. It shouldnt reflect minute details of who worked on what file in the run-up to it.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The solution:&lt;/strong&gt; Use &lt;code&gt;git pull&lt;/code&gt; &lt;code&gt;--``rebase&lt;/code&gt; instead. This tells &lt;code&gt;git&lt;/code&gt; to take the remote changes and replay your local changes on top of them:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579297414683_image.png&quot; alt=&quot;Before the git pull --rebase&quot;&gt;
&lt;img src=&quot;https://paper-attachments.dropbox.com/s_FE834B07340B42F115869E47B3A6D36A022DFDF5AFB60F065BB8B3DFF3BFD3B8_1579297500275_image.png&quot; alt=&quot;After the git pull --rebase&quot;&gt;&lt;/p&gt;
&lt;p&gt;Since were rebasing, there wont be a separate merge commit, and now we can use &lt;code&gt;git push&lt;/code&gt; without problem, since itll be a simple fast-forward.
&lt;strong&gt;Note:&lt;/strong&gt; In the previous section I talked about the pitfalls of a rebase when multiple people were using a branch. This does &lt;strong&gt;not&lt;/strong&gt; apply to &lt;code&gt;git pull&lt;/code&gt; &lt;code&gt;--``rebase&lt;/code&gt;. It is completely safe to use, because it only affects exactly those commits that are currently on your machine and not on remote.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Advent of Code 2019</title>
		<link href="https://cadolphs.github.io/blog/2019-12-4-Advent-of-code-2019/"/>
		<updated>2019-12-04T00:00:00Z</updated>
		<id>https://cadolphs.github.io/blog/2019-12-4-Advent-of-code-2019/</id>
		<content type="html">&lt;p&gt;I&#39;m participating again in this year&#39;s &lt;a href=&quot;https://adventofcode.com/2019&quot;&gt;Advent of Code&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I enjoy this coding challenge as the problems are usually small enough to be solved
without too much boilerplate and overhead, but tricky enough to really make you think.&lt;/p&gt;
&lt;p&gt;This year, I am trying out to use rather strict Test Driven Development (TDD) principles
to arrive at clean code and clean design for the solutions. My attempts are shared
on &lt;a href=&quot;https://github.com/cadolphs/advent_of_code_2019&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</content>
	</entry>
</feed>
